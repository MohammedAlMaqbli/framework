import orm.fields as fields
from orm.tools import keys, dict, checkBase64, empty
from orm.pouchdb import db

env = {}

class Model():
    _name = 'undefined'
    _inherit = False
    _fields = {}
    _values = {}
    _related = {}

    def __init__(self, _is_env=False, _is_singleton=True):
        self._is_env = _is_env
        self._is_singleton = _is_singleton
        if empty(env[self._name]):
           env[self._name] = True
           v'env[self._name] = new self.constructor(_is_env=true)'
           env[self._name]._is_env = True
        if self._is_env:
           return
        self.env = env
        schema = {'singular': self._name, 'plural': self._name}
        #Reserved fields
        if self._is_singleton:
           self.id = None
           self._fields['id'] = fields.Char(string="ID", related='_id', store=True)
           self._id = None
           self._fields['_id'] = fields.Char(string="ID (Raw)")
           self.rev = None
           self._fields['rev'] = fields.Char(string="DB Revision Number", related='_rev', store=True)
           self._rev = None
           self._fields['_rev'] = fields.Char(string="DB Revision Number")
        else:
           self.ids = []
           self._fields['ids'] = fields.Data(string="IDs")
        for key in [key for key in Object.getOwnPropertyNames(self.constructor.prototype) if key[0] != '_' and key not in ['constructor', 'env']]:
            #if key in self._fields:
            #   self[key] = self._fields[key]
            if self[key].type in ['many2one', 'one2many', 'many2many', 'one2one']:
               if not schema.relations:
                  schema.relations = {}
               type = 'belongsTo'
               if self[key].type in ['one2many', 'many2many']:
                  type = 'hasMany'
               if self[key].type != 'one2many':
                  schema.relations[key] = {type: self[key].relation}
               else:
                  schema.relations[key] = {type: {'type': self[key].relation, 'options': {'queryInverse': self[key].inverse}}}
            self._fields[key] = self[key]
            #self[key] = self._fields[key].default
            if self._is_singleton:
               if not empty(self._fields[key].related):
                  if empty(self._related[self._fields[key].related]):
                     self._related[self._fields[key].related] = []
                  self._related[self._fields[key].related].push(key)
               self._values[key] = self._fields[key].default
               v"""Object.defineProperty(self, key, {
               get: function() {return self._values[key]},
               set: function(value) {self._values[key] = self.adapt(key, value)},
               })"""
        #Disabling seal and freeze altogether because they cause bugs
        #v'Object.seal(self)'
        #v'Object.freeze(self._fields)'
        #v'Object.seal(self._values)'
        db.setSchema([schema])

    def browse(self, ids=False):
        if empty(ids):
           v'return new self.constructor()'
        elif ids.constructor == String:
           self = self.browse()
           db.get(ids).then(
           def (record):
               self.id = ids
               self._values = record
           )
        elif ids.constructor == Array:
           #self = self.browse()
           v'var self = new self.constructor(false, false)'
           db.rel.find(self._name, ids).then(
           def (record):
               self.ids = ids
               self._values = record[self._name]
           )
        return self

    def search(self, *args, **options):
        def query(record):
            results = []
            for arg in args:
                if arg == '|':
                   continue
                if arg[1] == '=':
                   results.push(record[arg[0]] == arg[2])
                elif arg[1] == '>':
                   results.push(record[arg[0]] > arg[2])
                elif arg[1] == '>=':
                   results.push(record[arg[0]] >= arg[2])
                elif arg[1] == '<':
                   results.push(record[arg[0]] < arg[2])
                elif arg[1] == '<=':
                   results.push(record[arg[0]] <= arg[2])
                elif arg[1] == 'in':
                   results.push(record[arg[0]] in arg[2])
            if empty(args):
               return True
            elif args[0] == '|':
               return results.some(
               def (result):
                   return result == True
               )
            else:
               return results.every( 
               def (result):
                   return result == True
               )
        if options['limit'] == 1:
           self = self.browse()
           db.rel.find(self._name).then(
           def (records):
               record = records[self._name].find(query)
               self.id = record.id
               self._values = record
               console.log(self)
           )
        else:
           v'var self = new self.constructor(false, false)'
           db.rel.find(self._name).then(
           def (records):
               self._values = records[self._name].filter(query)
               self.ids = [value.id for value in self._values]
               console.log(self)
           )
        return self

    def read(self):
        if self._is_env:
           return {}
        return self._values#{key: self.adapt(key, self[key]) for key in keys(self._fields)}

    def adapt(self, key, value):
        if self._is_env:
           return
        #if key == 'id':
        #   value = self._fields[key].value
        if self._fields[key].type in ['char', 'text']:
           value = String(value)
        elif self._fields[key].type == 'integer':
           value = parseInt(value)
           if isNaN(value):
              return Exception("Not a valid Number")
        elif self._fields[key].type == 'float':
           value = parseFloat(value)
           if isNaN(value):
              return Exception("Not a valid Number")
        elif self._fields[key].type == 'boolean':
           if value in ['true', 'True']:
              value = True
           elif value in ['false', 'False']:
              value = False
           elif type(value) == String:
              return Exception("Not a valid Boolean")
           else:
              value = Boolean(value)
        elif self._fields[key].type == 'binary':
           if not checkBase64(value):
              return Exception("Not a valid base64")
        elif self._fields[key].type == 'selection':
           if not value in dict(self._fields[key].selection):
              return Exception("Incorrect value")
        #Related operation
        if self._fields[key].store:
           if not empty(self._fields[key].related):
              self._values[self._fields[key].related] = value
           if not empty(self._related[key]):
              for field in self._related[key]:
                  self._values[field] = value
        return value
        #This is not Odoo I forgot
        '''elif self._fields[key].type in ['many2one', 'one2one']:
           if isinstance(value, models.Model):
              value = value.id
           else:
              value = parseInt(value)
              if isNaN(value):
                 return Exception("Not a valid ID")'''

    def update(self, values):
        if self._is_env:
           return        
        for key in keys(values):
            value = self.adapt(key, values[key])
            if self._is_singleton:
               self._values[key] = value
            else:
               for object in self._values:
                   object[key] = value       

    def create(self, values=False):
        if empty(values):
           values = self.read()
        else:
           merge(self.read(), values)
        if self._is_env:
           self = self.browse()
           self.update(values)
        del values['id']
        db.rel.save(self._name, values).then(
        def (record):
            self.id = record[self._name][0].id
        )
        return self

    def write(self, values=False):
        if empty(self.id) and empty(self.ids):
           return
        if empty(values):
           if not self._is_singleton:
              return
           values = self.read()
        else:
           #merge(self.read(), values)
           self.update(values)
           values = self.read()
        if self._is_singleton:
           #Maybe I'll use bulkDocs for revision checking instead of getting it
           db.get(self.id).then(
           def (record):
               return db.put(merge({'_id': record._id, '_rev': record._rev}, values))
           )
        else:
           db.bulkDocs(values).then(
           def (record):
               self._values = record
           )
        return self

    def unlink(self):
        if empty(self.id) and empty(self.ids):
           return
        if self._is_singleton:
           db.get(self.id).then(
           def (record):
               db.remove(record)
           )
        else:
           for value in self._values:
               value['_deleted'] = True
           db.bulkDocs(self._values)
        return True
