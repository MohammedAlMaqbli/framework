import orm.fields as fields
from orm.tools import keys, dict, checkBase64, empty
from orm.pouchdb import db
class Model():
    _name = 'undefined'
    _inherit = False
    _fields = {}
    _values = {}

    def __init__(self):
        schema = {'singular': self._name, 'plural': self._name}
        #Reserved fields
        self.id = fields.Char(string="ID")
        for key in [key for key in Object.getOwnPropertyNames(self.constructor.prototype) if key[0] != '_' and key not in ['constructor']]:
            if self[key].type in ['many2one', 'one2many', 'many2many', 'one2one']:
               if not schema.relations:
                  schema.relations = {}
               type = 'belongsTo'
               if self[key].type in ['one2many', 'many2many']:
                  type = 'hasMany'
               if self[key].type != 'one2many':
                  schema.relations[key] = {type: self[key].relation}
               else:
                  schema.relations[key] = {type: {'type': self[key].relation, 'options': {'queryInverse': self[key].inverse}}}
            self._fields[key] = self[key]
            self[key] = None
            self._values[key] = None
            v"""Object.defineProperty(self, key, {
            get: function() {return self._values[key]},
            set: function(value) {self._values[key] = self.adapt(key, value)},
            })"""
        v'Object.seal(self)'
        v'Object.freeze(self._fields)'
        v'Object.seal(self._values)'
        db.setSchema([schema])

    def read(self):
        return self._values

    def adapt(self, key, value):
        if key == 'id':
           value = self._fields[key].value
        elif self._fields[key].type in ['char', 'text']:
           value = String(value)
        elif self._fields[key].type == 'integer':
           value = parseInt(value)
           if isNaN(value):
              return Exception("Not a valid Number")
        elif self._fields[key].type == 'float':
           value = parseFloat(value)
           if isNaN(value):
              return Exception("Not a valid Number")
        elif self._fields[key].type == 'boolean':
           if value in ['true', 'True']:
              value = True
           elif value in ['false', 'False']:
              value = False
           elif type(value) == String:
              return Exception("Not a valid Boolean")
           else:
              value = Boolean(value)
        elif self._fields[key].type == 'binary':
           if not checkBase64(value):
              return Exception("Not a valid base64")
        elif self._fields[key].type in ['many2one', 'one2one']:
           if isinstance(value, models.Model):
              value = value.id
           else:
              value = parseInt(value)
              if isNaN(value):
                 return Exception("Not a valid ID")
        elif self._fields[key].type == 'selection':
           if not value in dict(self._fields[key].selection):
              return Exception("Incorrect value")
        return value

    def update(self, values):
        for key in keys(values):
            #value = self.adapt(key, values[key])
            self[key] = value

    def create(self, values=False):
        if empty(values):
           values = self.read()
        db.rel.save(self._name, values)
