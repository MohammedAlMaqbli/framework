import orm.models as models
import orm.fields as fields
import orm.tools as tools
import orm.api as api
from orm.tools import each, exist
from ir.ui import menu, view
from ir.sequence import add_sequence
from stock.location import defaults as location_default
from jasper.report import get_jasper_report
from utils import create_upload_button

sequence = {}
add_sequence('stock.picking', sequence)
add_sequence('stock.picking.putting', sequence)

class StockPicking(models.Model):
    _name = 'stock.picking'

    @api.server
    def _get_picking_number(self):
        return self.env['stock.picking'].with_context(order='name desc', limit=1).search().then(
        def (picking_id):
            if picking_id.length > 0:
               name = 'Operation ' + str.zfill((parseInt(picking_id.name.split(' ')[1]) + 1).toString(), 3)
               return name
            return 'Operation 001'
        )

    def _get_type(self):
         if v'typeof window' != 'undefined':
            return window.models.env.context.default_operation_type or None

    name = fields.Char(string="Operation Number", readonly=True, index=True)
    date = fields.Datetime(string="Date", defaults=tools.date.now)
    reference = fields.Char(string="Reference")
    state = fields.Selection(['draft', 'Draft'], ['confirmed', 'Confirmed'], ['validated', 'Validated'], string="Status", defaults='draft')
    type = fields.Selection(['picking', 'Picking'], ['putting', 'Receiving'], string="Type", required=True, defaults=_get_type)
    #picking_type = fields.Selection(['incoming', 'Incoming'], ['outgoing', 'Outgoing'], ['internal', 'Internal'], string="Picking Type")
    location_src_id = fields.Many2one('stock.location', string="Source Location")
    location_dest_id = fields.Many2one('stock.location', string="Destination Location")
    move_ids = fields.One2many('stock.move', 'picking_id', string="Move")
    pack_ids = fields.Many2many('stock.pack', string="Packs")
    #job_ids = fields.Many2many('wcs.job', string="WCS Jobs")
    receive_zone_id = fields.Many2one('stock.receive.zone', string="LC Zone")
    scan_zone = fields.Char(string="Scan Zone")
    parts = fields.Char(string="Parts")

    @api.onchange('scan_zone', async=True)
    def onchange_scan_zone(self):
        if not self.scan_zone: return
        zone_id = await [self.env['stock.receive.zone'].search(['name', '=', self.scan_zone])]
        @async
        def write_pack():
            pack_ids = await [self.env['stock.pack'].browse(self.pack_ids)]
            return pack_ids.write({'receive_zone': zone_id.name})
        write_pack()
        self.scan_zone = ''
        if not zone_id.length: return
        self.receive_zone_id = zone_id
        return self.write({'receive_zone_id': zone_id.id})

    def create(self, values=False, is_client=tools.configuration.client):
        promises = []
        if v"typeof window === 'undefined'":
           for object in each(values):
               if object.type == 'putting':
                  if not object.location_dest_id: object.location_dest_id = location_default.internal_id
                  if not object.location_src_id: object.location_src_id = location_default.external_id
               elif object.type == 'picking':
                  if not object.location_src_id: object.location_src_id = location_default.internal_id
                  if not object.location_dest_id: object.location_dest_id = location_default.external_id
               promise = self.env['ir.sequence'].browse(sequence['stock.picking' if object.type == 'picking' else 'stock.picking.putting']).then(
               def (sequence_id): return sequence_id.get_next()
               ).then(
               def (sequence):
                   object['name'] = ('Picking ' if object.type == 'picking' else 'Pallet ') + str.zfill(sequence.toString(), 3)
               )
               promises.push(promise)
        def after_create(result):
            if v"typeof window === 'undefined'": return result
            def create_move(record):
                return self.env['stock.pack'].browse(record.pack_ids).then(
                def (pack_ids):
                    promises = []
                    pack_ids.queue(
                    def (pack_id, next):
                        def create_move(qty):
                            return self.env['stock.move'].with_context(no_preload=True).create({'picking_id': record.id, 'pack_id': pack_id.id, 'product_id': pack_id.product_id, 'product_qty': qty})
                        promise = create_move(pack_id.product_qty)
                        promises.push(promise)
                        next()
                    )
                    return Promise.all(promises)
                )
            @async
            def each_picking():
                promises = []
                record = None
                for record in result:
                    promises.push(create_move(record))
                await (promises)
                return result
            if self._name == models.env.context.active_model: models.env.context.active_task.push(each_picking)
            else: return each_picking()
            return result
        if promises.length: return Promise.all(promises).then(
        def (): return self.__super__('create')(values=values, is_client=is_client).then(after_create)
        )
        return self.__super__('create')(values=values, is_client=is_client).then(after_create)

    def add_pack(self):
        if v'typeof window' == 'undefined': return
        picking_id = window.models.env.context.active_id
        picking_id.env.context.is_add_pack = True
        tools.navigate('/form/stock.pack')
        setTimeout(
        def ():
            def assign_picking():
                return picking_id.write({'pack_ids': (picking_id.pack_ids or []).concat(window.models.env.context.active_id.ids)}).then(
                def (result):
                    del picking_id.env.context.is_add_pack
                    return result
                )
            def create_moves():
                pack_id = window.models.env.context.active_id
                return self.env['stock.move'].create({'picking_id': picking_id.id, 'pack_id': pack_id.id, 'product_id': pack_id.product_id, 'product_qty': pack_id.product_qty})
            window.models.env.context.active_task.push(assign_picking)
            window.models.env.context.active_task.push(create_moves)
        , 0)

    def add_move(self):
        if v'typeof window' == 'undefined': return
        window.models.env.context.default_picking_id = window.models.env.context.active_id.id
        window.models.env.context.active_pack_ids = window.models.env.context.active_id.pack_ids
        tools.navigate('/form/stock.move')

    #@api.onchange('pack_ids')
    def onchange_pack(self):
        if self.type != 'picking':
           return
        move = self.env['stock.move'].search(['id', 'in', self.move_ids], ['pack_id', 'in', self.pack_ids])
        pack = self.env['stock.pack'].browse(self.pack_ids)
        return Promise.all([move, pack]).then(
        def (result):
            move_ids, pack_ids = result
            promises = []
            added_pack_ids = [move_id.pack_id for move_id in move_ids]
            for pack_id in pack_ids:
                if pack_id.id in added_pack_ids: continue
                promise = self.env['stock.move'].browse(pack_id.move_ids).then(
                def (move_ids):
                    if not move_ids.length: return
                    values = tools.copy(move_ids._values)
                    for value in values:
                        value.picking_id = self.id
                    return self.env['stock.move'].create(values)
                )
                promises.push(promise)
            return Promise.all(promises)
        )

    @api.server(async=True)
    def update_move(self, state):
        move_ids = []
        for record in self: move_ids.push(*record.move_ids)
        move_ids = await [self.env['stock.move'].browse(move_ids)]
        return move_ids.write({'state': state})

    @api.server
    def confirm(self):
        self.update_move('confirmed').catch(console.error)
        return self.write({'state': 'confirmed'})

    #@api.server
    def validate(self, immediate):
        self.update_move('validated').catch(console.error)
        for record in self:
            if immediate: break
            if record.type == 'putting' and not record.receive_zone_id: return tools.dialog.alert('Scan the zone first')
        return self.write({'state': 'validated'})

StockPicking()

menu.add({'id': 'picking', 'parent': 'stock', 'string': 'Picking', 'model': 'stock.picking', 'sequence': 1, 'view_id': 'stock.picking.tree_picking', 'context': {'default_operation_type': 'picking'}})
menu.add({'id': 'putting', 'parent': 'stock', 'string': 'Receiving', 'model': 'stock.picking', 'sequence': 1, 'view_id': 'stock.picking.tree_putting', 'context': {'default_operation_type': 'putting'}})

#menu.add({'id': 'picking_historical', 'parent': 'historical', 'string': 'Picking', 'model': 'stock.picking', 'sequence': 1, 'view_id': 'stock.picking.historical_picking', 'context': {'default_operation_type': 'picking'}})
#menu.add({'id': 'putting_historical', 'parent': 'historical', 'string': 'Putting', 'model': 'stock.picking', 'sequence': 2, 'view_id': 'stock.picking.historical_putting', 'context': {'default_operation_type': 'putting'}})

view.add({'model': 'stock.picking', 'mode': 'tree', 'string': 'Operation', 'arch': """
<tree domain="['type', '=', context.default_operation_type]">
    <field name="name"/>
    <field name="date"/>
    <field name="parts"/>
    <field name="receive_zone_id"/>
</tree>
"""})

view.add({'model': 'stock.picking', 'mode': 'tree_picking', 'string': 'Operation', 'arch': """
<tree-page title="Picking"/>
""", 'context': {'default_operation_type': 'picking', 'no_validated': True}})

view.add({'model': 'stock.picking', 'mode': 'tree_putting', 'string': 'Operation', 'arch': """
<tree-page title="Receiving"/>
""", 'context': {'default_operation_type': 'putting', 'no_validated': True}})

view.add({'model': 'stock.picking', 'mode': 'historical_picking', 'string': 'Operation', 'arch': """
<tree-page title="Picking"/>
""", 'context': {'default_operation_type': 'picking', 'no_validated': False}})

view.add({'model': 'stock.picking', 'mode': 'historical_putting', 'string': 'Operation', 'arch': """
<tree-page title="Receiving"/>
""", 'context': {'default_operation_type': 'putting', 'no_validated': False}})

view.add({'model': 'stock.picking', 'mode': 'form', 'string': 'Operation', 'arch': """
<form>
    <header>
        <button name="confirm" string="Confirm" invisible="active_id.state != 'draft'"/>
        <button name="validate" string="Validate" invisible="active_id.state != 'confirmed'"/>
        <field name="state" widget="statusbar"/>
    </header>
    <sheet>
        <group>
            <field name="name" readonly="active_id.state != 'draft'"/>
            <field name="reference"/>
        </group>
        <group>
            <field name="date"/>
            <field name="type"/>
            <field name="receive_zone_id" invisible="active_id.type != 'putting'"/>
        </group>
        <!--<group>
            <field name="location_src_id"/>
        </group>
        <group>
            <field name="location_dest_id"/>
        </group>-->
        <group width="100%">
            <scanner-field name="scan_zone"/>
        </group>
        <group width="100%">
            <field name="pack_ids">
                <tree create="false" choose="false">
                    <field name="product_id"/>
                    <field name="product_qty"/>
                    <field name="print_number"/>
                </tree>
            </field>
        </group>
        <!--<group width="100%" invisible="active_id.type != 'picking'">
            <button name="add_move" string="Add Items"/>
        </group>
        <group width="100%" invisible="active_id.type != 'picking'">
            <field name="move_ids">
                <tree>
                    <field name="product_id" domain="active_id.product_id ? ['id', '=', active_id.product_id] : ['id', 'not in', []]"/>
                    <field name="product_qty"/>
                    <field name="pack_id" domain="['id', 'in', parent.pack_ids || []]"/>
                </tree>
            </field>
        </group>-->
    </sheet>
</form>
"""})

menu.add({'id': 'settings_wms', 'string': 'WMS', 'parent': 'settings', 'model': 'stock.picking', 'view_id': 'stock.picking.settings', 'sequence': 5})

if v'typeof window' != 'undefined' and localStorage.wms_station_setting:
   localStorage.rapyd_home_view = 'stock.picking.tree_' + localStorage.wms_station_setting

def init_settings(props):
    tools.wait_exist(
    def (): return document.getElementById('wms_station_setting')
    ).then(
    def ():
        def onchange(event):
            localStorage.wms_station_setting = event.target.value
            window.location.reload()
        select = document.getElementById('wms_station_setting').querySelector('select')
        select.value = localStorage.wms_station_setting or ""
        select.onchange = onchange
    )

view.add({'model': 'stock.picking', 'mode': 'settings', 'init': init_settings, 'string': 'Operation', 'arch': """
<page title="WMS Settings">
    <list>
        <list-input label="Choose Station" type="select" id="wms_station_setting">
            <option/>
            <option value="picking">Picking Station</option>
            <option value="putting">Putting Station</option>
        </list-input>
    </list>
</page>
"""})

class PickingListFilter(models.Model):
    _name = 'stock.picking.list.filter'

    date = fields.Date(string="Date", required=True)

    def filter(self):
        del localStorage.last_list_sequence
        domain = [['date', '=', self.date]]
        if self.env.context.type: domain.push(['type', '=', self.env.context.type])
        tools.navigate('/tree/stock.picking.list?domain=' + JSON.stringify(domain))

PickingListFilter()

class PickingList(models.Model):
    _name = 'stock.picking.list'

    #@async
    def _get_model_code(self):
        console.log('dor')
        @async
        def check_picking_list():
            if self.sequence == 10: return
            picking_list_id = await [self.env['stock.picking.list'].with_context(limit=1).search(['date', '=', self.date], ['trolley_type_id', '=', self.trolley_type_id], ['sequence', '<', self.sequence], ['ready', '=', True])]
            if not picking_list_id.length:
               self.laser_scan = ''
               def back(): window.history.back()
               return tools.dialog.alert("Can't pick if there's still a running sequence", 'App', back)
        check_picking_list()
        return ''
        #model_id = await [self.env['mrp.bom'].browse(self.model_id)]
        #return model_id.code

    name = fields.Char(string="Picking List", readonly=True, index=True)
    type = fields.Selection(['mcvt', 'MCVT'], ['fwd_trf', '4WD TRF'], ['fwd_dps', '4WD DPS'], ['flexi', 'Flexi'], string="Type", index=True)
    sequence = fields.Integer(string="Sequence", index=True)
    sequence_id = fields.Many2one('mrp.sequence', string="Production Lot")
    model_id = fields.Many2one('mrp.bom', string="Model", required=True)
    model_code = fields.Char(string="Model Code", compute=_get_model_code, store=False)	
    trolley_type_id = fields.Many2one('stock.trolley.type', string="Trolley Type")
    line_ids = fields.One2many('stock.picking.list.line', 'picking_list_id', string="Lines")
    pack_ids = fields.One2many('stock.pack', 'picking_list_id', string="Packs")
    laser_scan = fields.Char(string="Laser Scan")
    called = fields.Boolean(string="AGV Called", index=True)
    ip_address = fields.Char(string="IP Address")
    date = fields.Datetime(string="Date", index=True)
    manual = fields.Boolean(string="Manual")
    #pickup_zone_id = fields.Many2one('stock.pickup.zone', string="Pickup Zone")
    pickup_zone = fields.Char(string="Pickup Zone")
    trolley_id = fields.Many2one('stock.trolley', string="Trolley")
    part_type = fields.Selection(['ckd', 'CKD'], ['local', 'Local'], ['inhouse', 'Inhouse'], string="Part Type", index=True)
    location_name = fields.Char(string="Location")
    printed = fields.Boolean(string="Printed", index=True)
    ready = fields.Boolean(string="Ready", index=True)
    is_pulley_finished = fields.Boolean(string="Is Pulley and Finished")

    @async
    def create(self, values=False, is_client=tools.configuration.client):
        if v'typeof window' != 'undefined': return self.__super__('create')(values=values, is_client=is_client)
        values = values if exist(values) else self.values
        for value in each(values):
            sequence = await (self.env['ir.sequence'].get_next('stock.picking.list'))
            value.name = 'Picking List ' + str.zfill(sequence.toString(), 3)
        result = await (self.__super__('create')(values=values, is_client=is_client))
        #if v'typeof window' != 'undefined': return result
        #@async
        #def after_create(record):
        #    product_id = await (self.env['product.product'].browse(record.product_id))
        #    await (self.env['stock.picking.list.line'].create({'picking_list_id': [value.id for value in each(values)][0], 'route': product_id.route, 'part_no': product_id.code, 'product_id': product_id.id, 'box': 1, 'qty_box': record.product_qty, 'product_qty': record.product_qty}))
        #bom_line_ids = await (self.env['mrp.bom.line'].search(['bom_id', 'in', [value.model_id for value in each(values)]]))
        #await (bom_line_ids.map(after_create))
        return result

    @api.onchange('laser_scan', async=True)
    def onchange_scan(self):
        barcode = self.laser_scan
        if not barcode: return
        @async
        def update_picked():
            line_ids = self.env.context.active_lines['stock.picking.list.line'].picking_list_id
            index = -1
            quantities = await ([line_id._get_received_qty() for line_id in line_ids])
            for quantity in quantities:
                document.querySelector('div.ag-row[row-id="' + (index += 1).toString() + '"] div.ag-cell[col-id=received_qty]').innerText = quantity
        def write(value):
            def write_value(): models.env.context.active_id.write(value)
            setTimeout(write_value, 500)
        def write_pack(pack_id, value):
            def write_value():
                update_picked()
                pack_id.write(value)
                #if 'dor' not in self.line_ids: self.line_ids.push('dor')
                #else: self.line_ids = [id for id in self.line_ids if id != 'dor']
                #models.env.context.refresh()
            setTimeout(write_value, 500)
        if not sum(parseFloat(cell.innerText) for cell in document.querySelectorAll('div.ag-cell[col-id=product_qty]')):
           def back(): window.history.back()
           return tools.dialog.alert("This Picking List doesn't need to be picked", "App", back)
        #picking_list_id = await [self.env['stock.picking.list'].with_context(limit=1).search(['date', '=', self.date], ['trolley_type_id', '=', self.trolley_type_id], ['sequence', '<', self.sequence], ['ready', '!=', True])]
        #if picking_list_id.length:
        #   self.laser_scan = ''
        #   return tools.dialog.alert("Can't pick if there's still a running sequence")
        self.env['log.data'].log('Scan', barcode, 'on Picking List')
        if barcode.split('-PICK-')[0] == 'LC':
           self.pickup_zone = self.laser_scan
           #pickup_zone_id = await [self.env['stock.pickup.zone'].search(['name', '=', barcode])]
           self.laser_scan = ''
           #if not pickup_zone_id.length: return
           #self.pickup_zone_id = pickup_zone_id.id
           return write({'pickup_zone': barcode})
        elif barcode.slice(0, 6) == 'Daisha':
           trolley_id = await [self.env['stock.trolley'].search(['name', '=', barcode])]
           self.laser_scan = ''
           if not trolley_id.length: return
           self.trolley_id = trolley_id.id
           return write({'trolley_id': trolley_id.id})
        value = None
        pack_id = None
        if '                   ' in barcode and barcode[0] != '{':
           numbers = [number for number in barcode.split('\n')[0].split('                   ')[1].split(' ') if not isNan(parseInt(number))]
           unique = 'CKD-' + barcode.split('\n')[0].split(' ').slice(-1)[0] + numbers[0]
           order_pack_id = await [self.env['purchase.order.pack'].with_context(limit=1).search(['name', '=', unique])]
           if order_pack_id.length:
              self.laser_scan = ''
              return tools.dialog.alert("This CKD Part is already picked")
           qty = numbers[1]
           code = barcode.split('\n')[0].split('                   ')[0].split('             ')[1].split('  ')[1].split(' ').join('')
           product_id = await [self.env['product.product'].with_context(limit=1).search(['code_trimmed', '=', code], ['type', '=', 'ckd'])]
           value = {'product_id': product_id.id}
        else: value = JSON.parse(barcode)
        #@async
        def get_product_ids():
            line_ids = self.env.context.active_lines['stock.picking.list.line'].picking_list_id #await [self.env['stock.picking.list.line'].browse(self.line_ids)]
            index = -1
            product_ids = {line_id.product_id: parseFloat(document.querySelector('div.ag-row[row-id="' + (index += 1).toString() + '"] div.ag-cell[col-id=product_qty]').innerText) for line_id in line_ids}
            valid = value.product_id in product_ids
            if not valid:
               self.laser_scan = ''
               tools.dialog.alert("Wrong part")
            if not product_ids[value.product_id]:
               valid = False
               self.laser_scan = ''
               tools.dialog.alert("This part doesn't need to be picked")
            return valid, product_ids
        valid, product_ids = get_product_ids()
        if '                   ' in barcode and barcode[0] != '{':
           order_pack_id = await [self.env['purchase.order.pack'].create({'name': unique, 'print_number': unique, 'product_id': product_id.id, 'product_qty': qty, 'inhouse_ckd': True})]
           pack_id = await [order_pack_id.receive(immediate=True)]
        if not valid: return
        if not pack_id: pack_id = await [self.env['stock.pack'].search(['order_pack_id', '=', value.id])]
        #valid, product_ids = await (validity)
        #if not valid: return
        #pack_id = await (pack_id)
        if pack_id.product_id not in product_ids:
           self.laser_scan = ''
           return tools.dialog.alert("Wrong part")
        if not product_ids[pack_id.product_id]:
           self.laser_scan = ''
           return tools.dialog.alert("This part doesn't need to be picked")
        if pack_id.picking_list_id:
           self.laser_scan = ''
           return tools.dialog.alert('This pack was already scanned by another picking list')
        if pack_id.on_hold:
           self.laser_scan = ''
           return tools.dialog.alert('This pack is on hold')
        self.laser_scan = ''
        self.pack_ids.push(pack_id.id)
        return write_pack(pack_id, {'picking_list_id': self.id})

    def print_barcode(self):
        if v'typeof window' != 'undefined' and window.printBarcode:
           for record in self: printBarcode(record.name)

    @async
    def print_list(self):
        values, line_ids = await ([self.read(format=True, without_null=True, relational_fields=['trolley_type_id']), self.env['stock.picking.list.line'].browse(self.line_ids)])
        line_ids = await [line_ids.read(format=True, without_null=True)]
        self.write({'printed': True})
        values[0].line_ids = line_ids
        url = await [get_jasper_report('/Solu/HPPM/Picking_List', {'data': JSON.stringify(values[0])})]
        window.open(url)

    def print_all(self):
        return Promise.all([record.print_list() for record in self])

    @async
    def print_list_old(self):
        report = self.env['report.report'].with_context(limit=1).search(['reference', '=', 'Picking-List'])
        read = self.read(format=True, fields=Object.keys(self._fields))
        line = self.env['stock.picking.list.line'].browse(self.line_ids[0:50])
        await (tools.exist(
        def (): return document.getElementById('reportbro_designer_iframe') and document.getElementById('reportbro_designer_iframe').contentWindow.$ and document.getElementById('reportbro_designer_iframe').contentWindow.$('#reportbro').reportBro
        ))
        data = await (read)
        data = data[0]
        line_ids = await (line)
        data.line_ids = await (line_ids.read(format=True, fields=Object.keys(line_ids._fields)))
        console.log(JSON.stringify(data))
        report_id = await (report)
        document.getElementById('reportbro_designer_iframe').contentWindow.$('#reportbro').reportBro('load', report_id.report_object)
        document.getElementById('reportbro_designer_iframe').contentWindow.$('#reportbro').reportBro('previewWithData', data)
        await (tools.exist(
        def (): return document.getElementById('reportbro_designer_iframe').contentWindow.document.getElementById('rbro_document_pdf_preview')
        ))
        #document.getElementById('reportbro_designer_iframe').style.display = ''
        document.getElementById('reportbro_designer_iframe').contentWindow.document.getElementById('rbro_document_pdf_preview').requestFullscreen()

    @async
    def create_picking(self):
        picking_id = await (self.env['stock.picking'].create({'location_src_id': self.env['stock.location'].location_defaults.internal_id, 'location_dest_id': self.env['stock.location'].location_defaults.scr_id, 'type': 'picking', 'pack_ids': self.pack_ids}))
        await [picking_id.validate()]
        return self.write({'ready': True})
        #tools.navigate('/form/stock.picking?id=' + picking_id.id)

    @async
    def picking_ready(self):
        line_ids, pack_ids = await ([self.env['stock.picking.list.line'].browse(self.line_ids), self.env['stock.pack'].browse(self.pack_ids)])
        lines = {}
        line_map = {}
        packs = {}
        pack_map = {}
        for line_id in line_ids:
            #if not lines[line_id.product_id]:
            lines[line_id.product_id] = 0
            line_map[line_id.product_id] = line_id
            packs[line_id.product_id] = 0
            pack_map[line_id.product_id] = []
            lines[line_id.product_id] += await [line_id.product_qty]
        for pack_id in pack_ids:
            pack_id.trolley_id = self.trolley_id
            if pack_map[pack_id.product_id]:
               packs[pack_id.product_id] += pack_id.product_qty
               pack_map[pack_id.product_id].push(pack_id)
        for line in lines:
            if packs[line] != lines[line]:
               console.log(line)
               console.log(packs[line], lines[line])
               product_id = await [self.env['product.product'].browse(line)]
               return tools.dialog.alert(lines[line] + ' Pcs of quantity is needed for part ' + product_id.name)
            line_id = line_map[line]
            actual_qty = line_id.actual_qty
            for pack_id in pack_map[line]:
                if pack_id.product_qty >= lines[line]:
                   pack_id.available_qty = pack_id.product_qty - actual_qty
                   break
                pack_id.available_qty = pack_id.product_qty - actual_qty
                if pack_id.available_qty >= 0: break
                actual_qty += pack_id.available_qty
                pack_id.available_qty = 0
            if line_id.consumed_pack_id:
               pack_id = await [self.env['stock.pack'].browse(line_id.consumed_pack_id)]
               pack_id.available_qty -= line_id.actual_qty
               pack_ids = pack_id
               line_id.consumed = True
        await ([pack_ids.write(), line_ids.write(), self.create_picking()])

    @async
    def call_agv(self):
        self.env['log.data'].log('Calling AGV on', self.name, 'id:', self.id, 'model:', self._name)
        host = self.ip_address or '172.16.1.213' #window.location.hostname
        @async
        def call_route():
            try:
                trolley_type_id = await [self.env['stock.trolley.type'].browse(self.trolley_type_id)]
                route_ids = await [self.env['agv.route'].search()] #['fitting', '=', trolley_type_id.name], ['pickup_zone', '=', parseInt(self.pickup_zone.split('-')[-1]).toString()])]
                def filter(route_id): return route_id.fitting == trolley_type_id.name and route_id.picking_zone == parseInt(self.pickup_zone.split('-')[-1]).toString()
                route_id = route_ids.filter(filter)
                if not route_id.name: tools.dialog.alert('Route for Zone ' + self.pickup_zone + ' and Trolley Type ' + trolley_type_id.name + ' is not configured')
                response = await (fetch('http://' + host + ':8000/?route=' + route_id.name))
                text = await (response.text())
                tools.dialog.alert(text)
            except Exception as error:
                tools.dialog.alert(error.stack)
        await [call_route()]
        return self.write({'called': True})

    @api.server(async=True)
    def update_location(self, location_id, is_pulley):
        sequence_id, location_id = await ([self.env['mrp.sequence'].browse(self.sequence_id) if is_pulley else None, self.env['stock.location'].browse(location_id)])
        return await ([sequence_id.write({'location_name': location_id.name}) if is_pulley else None, self.write({'location_name': location_id.name, 'is_pulley_finished': True if is_pulley else False})])

    @api.server(async=True)
    def check_pulley(self, location_id):
        if not self.pack_ids or not self.pack_ids.length: return
        bom = self.env['mrp.bom'].browse(self.model_id)
        pack_ids = await [self.env['stock.pack'].browse(self.pack_ids)]
        @async
        def create_quant(pack_id):
            if pack_id.location_id:
               await [self.env['stock.quant'].create({'product_id': pack_id.product_id, 'product_qty': -pack_id.product_qty, 'location_id': pack_id.location_id})]
            await [self.env['stock.quant'].create({'product_id': pack_id.product_id, 'product_qty': pack_id.product_qty, 'location_id': location_id})]
        pulley_location_updated = False
        for pack_id in pack_ids:
            if pack_id.is_pulley and not pulley_location_updated:
               self.update_location(location_id, True)
               pulley_location_updated = True
               sequence_id = await [self.env['mrp.sequence'].browse(self.sequence_id)]
               sequence_id.write({'finished': True})
               bom_id = await (bom)
               bom_id.move_pulley_out(location_id, pack_id, sum(pack_sum_id.product_qty for pack_sum_id in pack_ids if pack_sum_id.product_id == pack_id.product_id), [pack_id.product_id for pack_id in pack_ids])
            await ([create_quant(pack_id), self.env['stock.move'].create({'pack_id': pack_id.id, 'product_id': pack_id.product_id, 'product_qty': pack_id.product_qty, 'location_src_id': pack_id.location_id, 'location_dest_id': location_id}), pack_id.write({'location_id': location_id})])
        if not pulley_location_updated: return self.update_location(location_id, False)

PickingList()

menu.add({'id': 'picking_list', 'string': 'Picking List', 'sequence': 8})
menu.add(id='picking_list_queue', parent='picking_list', model='stock.picking.list.filter', view_id='stock.picking.list.filter.wizard', string="Queue & Print", sequence=1)
menu.add(id='picking_list_mcvt', parent='picking_list', model='stock.picking.list.filter', view_id='stock.picking.list.filter.mcvt', string="MCVT", sequence=2)
menu.add(id='picking_list_fwd_trf', parent='picking_list', model='stock.picking.list.filter', view_id='stock.picking.list.filter.fwd_trf', string="4WD TRF", sequence=3)
menu.add(id='picking_list_fwd_dps', parent='picking_list', model='stock.picking.list.filter', view_id='stock.picking.list.filter.fwd_dps', string="4WD DPS", sequence=3)
menu.add(id='picking_list_flexi', parent='picking_list', model='stock.picking.list.filter', view_id='stock.picking.list.filter.flexi', string="Flexi", sequence=4)

view.add(init=create_upload_button, model='stock.picking.list', mode='tree', arch="""
<tree title="Picking List" limit="2000"> <!--domain="context.type ? ['type', '=', context.type] : []">-->
    <field name="date"/>
    <field name="sequence" sort="asc"/>
    <field name="model_id"/>
    <!--<field name="model_code"/>-->
    <field name="trolley_type_id"/>
    <field name="part_type"/>
    <field name="printed"/>
    <field name="called" string="Finished"/>
</tree>
""", action={'print_all': 'Print'})

view.add(model='stock.picking.list.filter', mode='wizard', arch="""
<form>
    <sheet>
        <group>
            <field name="date"/>
            <button name="filter" string="Filter"/>
        </group>
    </sheet>
</form>
""")

view.add(model='stock.picking.list.filter', mode='mcvt', arch="""
<form mode="mcvt">
    <sheet>
        <group>
            <field name="date"/>
            <button name="filter" string="Filter"/>
        </group>
    </sheet>
</form>
""", context={'type': 'mcvt'})

view.add(model='stock.picking.list.filter', mode='fwd_trf', arch="""
<form mode="fwd_trf">
    <sheet>
        <group>
            <field name="date"/>
            <button name="filter" string="Filter"/>
        </group>
    </sheet>
</form>
""", context={'type': 'fwd_trf'})

view.add(model='stock.picking.list.filter', mode='fwd_dps', arch="""
<form mode="fwd_dps">
    <sheet>
        <group>
            <field name="date"/>
            <button name="filter" string="Filter"/>
        </group>
    </sheet>
</form>
""", context={'type': 'fwd_dps'})

view.add(model='stock.picking.list.filter', mode='flexi', arch="""
<form mode="flexi">
    <sheet>
        <group>
            <field name="date"/>
            <button name="filter" string="Filter"/>
        </group>
    </sheet>
</form>
""", context={'type': 'flexi'})

view.add(model='stock.picking.list', mode='form', arch="""
<form>
    <style>
        div.card-body a:nth-child(2), div.card-body a:nth-child(3), .rapyd-tree-delete-button {
          display: none !important;
        }
        div.card-body a:nth-child(6) {
          display: unset !important;
        }
        @media only screen and (max-width: 960px) {
          .component-group[style="float: left; padding: 10px; margin-top: 20px; height: auto;"] {
            width: 100vw;
          }
        }
    </style>
    <header>
        <button name="print_list" string="Print"/>
        <button name="picking_ready" string="Ready" invisible="active_id.ready == True"/>
        <button name="call_agv" string="Call" invisible="active_id.ready != True || active_id.called == True"/>
    </header>
    <sheet>
        <group>
            <field name="name"/>
            <field name="sequence"/>
            <field name="trolley_type_id"/>
        </group>
        <group>
            <field name="model_id"/>
            <field name="ip_address"/>
            <field name="trolley_id" readonly="True"/>
            <field name="pickup_zone" readonly="True"/>
        </group>
        <group width="100%">
            <field name="line_ids">
                <tree create="false">
                    <field name="product_id"/>
                    <field name="product_qty"/>
                    <field name="received_qty"/>
                    <field name="box"/>
                    <field name="zones"/>
                </tree>
            </field>
        </group>
        <group>
            <scanner-field name="laser_scan"/>
            <!--<field name="laser_scan" invisible="True"/>-->
        </group>
        <group width="100%">
            <field name="pack_ids">
                <tree create="false">
                    <field name="product_id"/>
                    <field name="product_qty"/>
                    <field name="print_number"/>
                </tree>
            </field>
        </group>
        <!--<iframe ref="frame" id="reportbro_designer_iframe" frameborder="0" width="100%" height="500px" style="position: absolute; top: -9999px; left: -9999px; border-radius: 5px" src="reportbro/index.html"/>-->
    </sheet>
</form>
""")

add_sequence('stock.picking.list')

class PickingListLine(models.Model):
    _name = 'stock.picking.list.line'

    @async
    def _get_part_no(self):
        if not self.product_id: return
        product_id = await (self.env['product.product'].browse(self.product_id))
        return product_id.code

    @async
    def _get_part_qty_box(self):
        if not self.product_id: return
        product_id = await (self.env['product.product'].browse(self.product_id))
        return Math.max(product_id.qty_box, self.product_qty)

    @async
    def _get_received_qty(self):
        picking_id = self.env.context.active_id
        if not picking_id: return 0
        if not picking_id.pack_ids or not picking_id.pack_ids.length: return 0
        def wait(): return self.env.context.active_lines and self.env.context.active_lines['stock.pack'] and self.env.context.active_lines['stock.pack'].picking_list_id
        await [tools.wait_exist(wait)]
        lines = self.env.context.active_lines
        def filter(pack_id): return pack_id.product_id == self.product_id
        pack_ids = lines['stock.pack'].picking_list_id.filter(filter)
        return sum(pack_id.product_qty for pack_id in pack_ids)

    @async
    def _get_part_qty(self):
        if self.manual: return self.actual_qty
        picking_list_id = await [self.env['stock.picking.list'].with_context(limit=1).search(['date', '=', self.date], ['trolley_type_id', '=', self.trolley_type_id], ['sequence', '<=', self.sequence], ['called', '!=', True], ['id', '!=', self.id])]
        if picking_list_id.length: return 0
        if self.consumed: return self.cached_product_qty
        quantity = 0
        pack_id = await [self.env['stock.pack'].with_context(limit=1).search(['product_id', '=', self.product_id.id], ['location_id', 'in', (location_default.scr_id, location_default.assy_id)], ['available_qty', '>=', self.actual_qty])]
        if pack_id.length: quantity = pack_id.available_qty - self.actual_qty
        else:
           pack_id = await [self.env['stock.pack'].with_context(limit=1).search(['product_id', '=', self.product_id.id], ['location_id', 'in', (location_default.scr_id, location_default.assy_id)], ['available_qty', '>', 0])]
           if pack_id.length: quantity = pack_id.available_qty - self.actual_qty
        self.consumed_pack_id = pack_id
        """picking_line_ids = await [self.env['stock.picking.list.line'].search(['product_id', '=', self.product_id], ['date', '<=', self.date], ['consumed', '!=', True])]
        picking_line_ids = picking_line_ids.order_by('date')
        dates = []
        for picking_line_id in picking_line_ids:
            if picking_line_id.date in dates: continue
            else: dates.push(picking_line_id.date)
        records_by_dates = {}
        for date in dates:
            records_by_dates[date] = picking_line_ids.filter(
            def (record):
                return record.date == date
            ).order_by('sequence')
        quantity = 0
        #group_line_ids = None
        for date in dates:
            for picking_line_id in records_by_dates[date]:
                if date == self.date and picking_line_id.sequence == self.sequence: break
                if quantity <= 0:
                   quantity = picking_line_id.qty_box * picking_line_id.actual_box
                   #group_line_ids = picking_line_ids.browse()
                quantity -= picking_line_id.actual_qty
                #group_line_ids.add(picking_line_id)
        #self.group_line_ids = group_line_ids"""
        #box = await (self.box)
        if quantity > 0: quantity = 0
        else:
           #product_id = await [self.env['product.product'].browse(self.product_id)]
           quantity = (self.qty_box * self.min_box) + quantity
        self.cached_product_qty = quantity
        return quantity

    @async
    def _get_box(self):
        quantity = await [self.product_qty]
        if not quantity: return 0
        else:
           return Math.ceil(quantity / self.qty_box)

    @async
    def _get_zones(self):
        pack_ids = await [self.env['stock.pack'].search(['location_id', '=', self.env['stock.location'].location_defaults.internal_id], ['product_id', '=', self.product_id])]
        return list({pack_id.receive_zone for pack_id in pack_ids.sort_by('date')})[0:3].join(', ')

    picking_list_id = fields.Many2one('stock.picking.list', string="Picking List")
    #group_line_ids = fields.Many2many('stock.picking.list.line', string="Part List Group")
    route = fields.Integer(string="Route")
    part_no = fields.Char(string="Part No.") #, compute=_get_part_no, store=True)
    product_id = fields.Many2one('product.product', string="Part")
    qty_box = fields.Integer(string="Qty/Box") #, compute=_get_part_qty_box, store=True)
    min_box = fields.Integer(string="Minimum Box")
    box = fields.Integer(string="Box", compute=_get_box, store=True)
    actual_box = fields.Integer(string="Actual Box")
    cached_product_qty = fields.Integer(string="Total Qty")
    product_qty = fields.Integer(string="Total Qty", compute=_get_part_qty, store=True)
    received_qty = fields.Integer(string="Picked Qty", compute=_get_received_qty, store=False)
    actual_qty = fields.Integer(string="Actual Qty")
    description = fields.Char(string="Description")
    date = fields.Datetime(string="Date")
    sequence = fields.Integer(string="Sequence")
    consumed = fields.Boolean(string="Consumed")
    consumed_pack_id = fields.Many2one('stock.pack', string="Pack to Consume")
    manual = fields.Boolean(string="Manual")
    zones = fields.Char(string="Zones", compute=_get_zones, store=False)

    def print_barcode(self):
        for record in self:
            window.printBarcode(record.part_no)

    def remove(self):
        picking_id = self.env.context.active_id
        if picking_id._name == 'stock.picking.list':
           picking_id.pack_ids = [pack_id for pack_id in picking_id.pack_ids if pack_id != self.id]
        return self.write({'picking_list_id': None})

PickingListLine()

view.add(model='stock.picking.list.line', mode='tree', arch="""
<tree>
    <field name="route"/>
    <field name="part_no"/>
    <field name="product_id"/>
    <field name="qty_box"/>
    <field name="box"/>
    <field name="product_qty"/>
    <field name="description"/>
</tree>
""", action={'print_barcode': 'Print'})

class PickingManual(models.Model):
    _name = 'stock.picking.manual'

    type = fields.Selection(['mcvt', 'MCVT'], ['fwd_trf', '4WD TRF'], ['fwd_dps', '4WD DPS'], ['flexi', 'Flexi'], string="Type", required=True)
    date = fields.Date(string="Date", required=True)
    sequence = fields.Integer(string="Sequence")
    sequence_id = fields.Many2one('mrp.sequence', string="Lot No.", required=True)
    line_ids = fields.Many2many('stock.picking.manual.line', string="Lines")

    @api.onchange('sequence', async=True)
    def onchange_sequence(self):
        if self.sequence_changing or not self.sequence or not self.type or not self.date: return
        self.sequence_changing = True
        date = new Date(self.date)
        date.setHours(0, 0, 0, 0)
        sequence_id = await [self.env['mrp.sequence'].search(['date', '=', date.toISOString()], ['type', '=', self.type], ['sequence', '=', self.sequence])]
        if not sequence_id.length: return
        self.sequence_id = sequence_id
        self.sequence_changing = False

    @api.onchange('sequence_id', async=True)
    def onchange_sequence_id(self):
        if self.sequence_changing or not self.sequence_id: return
        self.sequence_changing = True
        sequence_id = await [self.env['mrp.sequence'].browse(self.sequence_id)]
        if not sequence_id.length: return
        self.type = sequence_id.type
        self.sequence = sequence_id.sequence
        self.sequence_changing = False

    @async
    def create_manual_list(self):
        list_id = await [self.create_manual_list_server()]
        self.env['log.data'].log('Create', list_id.name, 'id:', list_id.id, 'model:', list_id._name)
        return tools.navigate('/form/stock.picking.list?id=' + list_id)

    @api.server(async=True)
    def create_manual_list_server(self):
        sequence_id = await [self.env['mrp.sequence'].browse(self.sequence_id)]
        #bom_id = await [self.env['mrp.bom'].browse(sequence_id.bom_id)]
        #bom_line_ids = await [self.env['mrp.bom.line'].browse(bom_id.line_ids)]
        promises = []
        routes = {index: 0 for index in range(1, 6)}
        trolley_group = {}
        date = new Date()
        list_id, line_ids = await ([self.env['stock.picking.list'].create({'manual': True, 'model_id': sequence_id.bom_id, 'sequence_id': sequence_id.id, 'sequence': sequence_id.sequence, 'date': date, 'type': sequence_id.type}), self.env['stock.picking.manual.line'].browse(self.line_ids)])
        for line_id in line_ids:
            product_id = await [self.env['product.product'].browse(line_id.product_id)]
            promise = self.env['stock.picking.list.line'].create({'manual': True, 'route': 1, 'product_id': line_id.product_id, 'actual_qty': line_id.product_qty, 'qty_box': line_id.product_qty, 'part_no': product_id.code, 'actual_box': line_id.product_qty, 'picking_list_id': list_id.id, 'sequence': sequence_id.sequence, 'date': date})
            promises.push(promise)
        promises.push(list_id.write({'name': 'Emergency ' + list_id.name}))
        await (promises)
        return list_id.id

PickingManual()

class PickingManualLine(models.Model):
    _name = 'stock.picking.manual.line'

    product_id = fields.Many2one('product.product', string="Product", required=True)
    product_qty = fields.Integer(string="Quantity")

PickingManualLine()

menu.add(id='picking_list_manual', parent='picking_list', model='stock.picking.manual', view_id='stock.picking.manual.create', string="Manual Picking List", sequence=10)

view.add(model='stock.picking.manual', mode='create', arch="""
<form>
    <sheet>
        <group>
            <field name="type"/>
        </group>
        <group>
            <field name="date"/>
        </group>
        <group title="Sequence">
            <field name="sequence"/>
            <field name="sequence_id"/>
        </group>
        <group width="100%">
            <field name="line_ids">
                <tree>
                    <field name="product_id"/>
                    <field name="product_qty"/>
                </tree>
            </field>
        </group>
        <group>
            <button name="create_manual_list" string="Create"/>
        </group>
    </sheet>
</form>
""")
