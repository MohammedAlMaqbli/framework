import orm.exceptions as exceptions
import orm.models as models
import orm.fields as fields
import orm.tools as tools
import orm.api as api
import orm.exceptions as exceptions
from orm.pouchdb import db
from ir.ui import menu, view
from ir.sequence import add_sequence
from stock.location import defaults as location_defaults
from jasper.report import get_jasper_report
from utils import create_upload_button

class PurchaseOrder(models.Model):
    _name = 'purchase.order'

    def _get_boxes(self):
        return self.pack_ids.length

    @async
    def _get_received_qty(self):
        if not self.env.context.actual_receiving: return None
        if not self.printed: return 0
        pack_ids = await [self.env['stock.pack'].search(['order_pack_id', 'in', self.pack_ids])]
        if not pack_ids.length: return 0
        picking_ids = self.env['stock.picking'].search(['state', '=', 'validated'])
        moves = {}
        #quantity = 0
        @async
        def get_moves(pack_id):
            #nonlocal quantity
            quantity = 0
            move_ids = await [self.env['stock.move'].browse(pack_id.move_ids)]
            console.log(move_ids.length)
            picking_validated_ids = await (picking_ids)
            for move_id in move_ids:
                #picking_id = picking_validated_ids.find(move_id.picking_id)
                #alert(picking_id.name)
                if move_id.location_dest_id == location_defaults.internal_id and move_id.picking_id in picking_validated_ids.ids: quantity += move_id.product_qty
            return quantity
        promises = []
        for pack_id in pack_ids:
            promises.push(get_moves(pack_id))
        quantities = await (promises)
        return sum(quantities)

    @async
    def _get_received_boxes(self):
        if not self.env.context.actual_receiving: return None
        if not self.printed: return 0
        pack_ids = await [self.env['stock.pack'].search(['order_pack_id', 'in', self.pack_ids])]
        if not pack_ids.length: return 0
        picking_ids = self.env['stock.picking'].search(['state', '=', 'validated'])
        moves = {}
        #quantity = 0
        @async
        def get_boxes(pack_id):
            #nonlocal quantity
            quantity = 0
            move_ids = await [self.env['stock.move'].browse(pack_id.move_ids)]
            picking_validated_ids = await (picking_ids)
            for move_id in move_ids:
                if move_id.location_dest_id == location_defaults.internal_id and move_id.picking_id in picking_validated_ids.ids: quantity += 1
            return quantity
        promises = []
        for pack_id in pack_ids:
            promises.push(get_boxes(pack_id))
        quantities = await (promises)
        return sum(quantities)

    name = fields.Char(string="PO Number")
    part_no = fields.Char(string="Part No.", index=True)
    product_id = fields.Many2one('product.product', string="Part", index=True)
    product_qty = fields.Float(string="Qty (Pcs)")
    boxes = fields.Integer(string="Qty (Box)", compute=_get_boxes, store=False)
    printed = fields.Boolean(string="Printed", index=True)
    ps_month = fields.Char(string="P/S Month", index=True)
    ps_code = fields.Char(string="P/S Code", index=True)
    pl_from = fields.Char(string="P/L From", index=True)
    pl_to = fields.Char(string="P/L To", index=True)
    lot_no = fields.Char(string="Lot No.")
    pack_ids = fields.One2many('purchase.order.pack', 'order_id', string="Packs")
    date = fields.Datetime(string="Date", index=True)
    date_string = fields.Char(string="Date (String)", index=True)
    received_qty = fields.Float(string="Received Qty (Pcs)", compute=_get_received_qty, store=False)
    received_boxes = fields.Float(string="Received Qty (Box)", compute=_get_received_boxes, store=False)

    @async
    def create(self, values=False, is_client=tools.configuration.client):
        if v'typeof window' != 'undefined': return self.__super__('create')(values=values, is_client=is_client)
        values = values if tools.exist(values) else self.values
        for value in tools.each(values):
            sequence = await (self.env['ir.sequence'].get_next('purchase.order'))
            value.name = 'PO ' + str.zfill(sequence.toString(), 3)
        result = await (self.__super__('create')(values=values, is_client=is_client))
        return result

    @async
    def print_label(self):
     try:
        date = new Date()
        print_date = date.getDate().toString() + date.getMilliseconds().toString() + date.getSeconds()
        count = 0
        self.env['log.data'].log('Printing', self.name, 'id:', self.id, 'model:', self._name)
        values = []
        for record in self:
            value = record.read()
            value.date_string = value.date_string.split('/')[0:2].join('/')
            pack_ids = await [self.env['purchase.order.pack'].browse(record.pack_ids)]
            for pack_id in pack_ids:
                if pack_id.print_number: continue
                count += 1
                pack_id.print_number = print_date + '-' + str.zfill(count.toString(), 4)
                pack_id.write()
            pack_values = await [pack_ids.read(format=True, without_null=True, relational_fields=['product_id'])]
            for pack_value in pack_values:
                pack_value.order_id = value
                #for key in value:
                #    if key not in pack_value: pack_value[key] = value[key]
            values.push(*pack_values)
        url = await [get_jasper_report('/Solu/HPPM/Purchase_Order', {'data': JSON.stringify(values)})]
        self.write({'printed': True})
        window.open(url)
     except Exception as error:
        alert(error.stack or error.message)

    def get_box_quantities(self, quantity, product_id):
        boxes = quantity / product_id.qty_box
        rounded_boxes = parseInt(boxes)
        box_quantities = [product_id.qty_box for index in range(rounded_boxes)]
        residual = boxes - rounded_boxes
        if residual != 0: box_quantities.push(quantity - (rounded_boxes * product_id.qty_box))
        return box_quantities

    @api.server(async=True)
    def compute_pack(self, quantity):
        product_id = await [self.env['product.product'].browse(self.product_id)]
        if not product_id.qty_box: return
        if not quantity: quantity = self.product_qty
        promises = []
        for box_quantity in self.get_box_quantities(quantity, product_id):
            promise = self.env['purchase.order.pack'].create({'name': self.name, 'order_id': self.id, 'part_no': self.part_no, 'part_name': product_id.name.split(' - ')[1], 'product_id': self.product_id, 'product_qty': box_quantity})
        return await (promises)


    @api.server(async=True)
    def recompute_pack(self, quantity):
        if not self.printed:
           write = self.write({'product_qty': quantity})
           pack_ids = await [self.env['purchase.order.pack'].browse(self.pack_ids)]
           await (write)
           return await ([pack_ids.unlink(), self.compute_pack()])
        if quantity > self.product_qty:
           self.write({'product_qty': quantity})
           return self.compute_pack(quantity - self.product_qty)
        if quantity == self.product_qty: return
        product_id = await [self.env['product.product'].browse(self.product_id)]
        original_quantities = self.get_box_quantities(self.product_qty, product_id)
        new_quantities = self.get_box_quantities(self.product_qty - quantity, product_id)
        promises = [self.write({'product_qty': quantity})]
        for new_quantity in new_quantities:
            if new_quantity not in original_quantities: promises.push(self.env['purchase.order.pack'].create({'name': self.name, 'order_id': self.id, 'part_no': self.part_no, 'part_name': product_id.name.split(' - ')[1], 'product_id': self.product_id, 'product_qty': new_quantity}))
        return await (promises)

PurchaseOrder()

pack_sequence = 0

class PurchaseOrderPack(models.Model):
    _name = 'purchase.order.pack'

    def _get_barcode(self):
        json = tools.copy(self.read())
        del json.barcode
        del json.ids
        del json.rev
        del json._rev
        del json._id
        for key in json:
            if not json[key]: del json[key]
        return window.PDF417(JSON.stringify(json), 1.5, 0.75).split('base64,')[1]

    name = fields.Char(string="PO Number")
    part_no = fields.Char(string="Part No.")
    part_name = fields.Char(string="Part Name")
    product_id = fields.Many2one('product.product', string="Part")
    product_qty = fields.Float(string="Quantity")
    order_id = fields.Many2one('purchase.order', string="Purchase Order")
    barcode = fields.Text(string="Barcode", compute=_get_barcode, store=False)
    received = fields.Boolean(string="Received")
    inhouse_ckd = fields.Boolean(string="Inhouse/CKD", index=True)
    ckd_id = fields.Many2one('stock.receive.ckd', string="Receiving CKD")
    is_pulley = fields.Boolean(string="Is Pulley")
    print_number = fields.Char(string="Print No.")

    @api.onchange('product_qty')
    def onchange_qty(self):
        if not self.product_qty: return
        return self.write({'product_qty': self.product_qty})

    """@async
    def create(self, values=False, is_client=tools.configuration.client):
        if v'typeof window' == 'undefined': return self.__super__('create')(values=values, is_client=is_client)
        result = await [self.__super__('create')(values=values, is_client=is_client)]
        for record in result:
            await [record.write({'barcode': JSON.stringify(self.read())})]
        return result"""

    @async
    def print_label(self):
     try:
        date = new Date()
        print_date = date.getDate().toString() + date.getMilliseconds().toString() + date.getSeconds()
        count = 0
        self.env['log.data'].log('Printing', self.name, 'id:', self.id, 'model:', self._name)
        for record in self:
            if record.ckd_id and not record.received: record.receive(immediate=True)
            if record.print_number: continue
            count += 1
            record.print_number = print_date + '-' + str.zfill(count.toString(), 4)
            record.write()
        values = await [self.read(format=True, without_null=True, relational_fields=['product_id', 'order_id'])]
        #order_id = None
        @async
        def write_order_id(id):
            order_id = await [self.env['purchase.order'].browse(id)]
            return order_id.write({'printed': True})
        ids = []
        for value in values:
            if value.order_id:
               if value.order_id.date_string: value.order_id.date_string = value.order_id.date_string.split('/')[0:2].join('/')
               if value.order_id.id: ids.push(value.order_id.id)
            #for key in po_value:
            #    if key not in value: value[key] = po_value[key] or ''
        url = await [get_jasper_report('/Solu/HPPM/Purchase_Order', {'data': JSON.stringify(values)})]
        for id in ids: write_order_id(id)
        window.open(url)
     except Exception as error:
        alert(error.stack or error.message)

    @async
    def receive(self, immediate):
        pack_ids = []
        for record in self:
            if record.received: return tools.alert('One of the PO is already received')
        quant_map = {}
        @async
        def create_quant_report(pack_id):
            if quant_map[pack_id.product_id]: return
            quant_map[pack_id.product_id] True
            quant_report_id = await [self.env['stock.quant.report'].search(['product_id', '=', pack_id.product_id])]
            if quant_report_id.length: return
            return self.env['stock.quant.report'].create({'product_id': pack_id.product_id})
        @async
        def create_quant(pack_id):
            create_quant_report(pack_id)
            await [self.env['stock.quant'].create({'product_id': pack_id.product_id, 'product_qty': pack_id.product_qty, 'location_id': pack_id.location_id})]
        for record in self:
            nonlocal pack_sequence
            pack_sequence += 1
            if pack_sequence >= 10: pack_sequence = 1
            pack_id, order_id = await ([self.env['stock.pack'].create({'name': 'Pack ' + record.name.replace('PO ', '') + '-' + (pack_sequence + (new Date()).getMilliseconds().toString()), 'location_id': location_defaults.internal_id, 'product_id': record.product_id, 'product_qty': record.product_qty, 'order_pack_id': record.id, 'is_pulley': record.is_pulley}), record.write({'received': True})])
            create_quant(pack_id)
            pack_ids.push(pack_id.id)
        picking_id = await [self.env['stock.picking'].create({'location_src_id': location_defaults.external_id, 'location_dest_id': location_defaults.internal_id, 'type': 'putting', 'pack_ids': pack_ids})]
        self.env['log.data'].log('Receive', self.name, 'id:', self.id, 'model:', self._name)
        if immediate:
           return picking_id.validate(immediate=True)
        tools.navigate('/view/stock.picking.form?id=' + picking_id.id)

    def cancel(self):
        @async
        def cancel_pack(self):
            if not self.received: return
            pack_id = await [self.env['stock.pack'].search(['order_pack_id', '=', self.id])]
            move_id = await [self.env['stock.move'].search(['pack_id', '=', pack_id.id])]
            if move_id.length > 1: return
            self.env['stock.quant'].create({'product_id': pack_id.product_id, 'product_qty': -pack_id.product_qty, 'location_id': move_id.location_dest_id})
            await ([move_id.unlink(), pack_id.unlink(), self.write({'received': False})])
        return Promise.all([cancel_pack(record) for record in self])

PurchaseOrderPack()

add_sequence('purchase.order')

menu.add({'id': 'hppm_data', 'string': 'Data', 'sequence': 25})

menu.add({'id': 'hppm_po', 'parent': 'mrp_planning', 'string': 'Purchase Order', 'model': 'purchase.order', 'sequence': 10})

menu.add(id='receiving_print', parent='receiving', model='purchase.order.pack', string="Reprint Inhouse & CKD", sequence=5)

menu.add(id='receiving_actual', parent='receiving', model='purchase.order', view_id='purchase.order.actual_receiving', string="Actual Receiving", sequence=15)

view.add({'model': 'purchase.order.pack', 'mode': 'tree', 'string': False, 'arch': """
<tree domain="['inhouse_ckd', '=', True]">
    <field name="name"/>
    <field name="product_id"/>
    <field name="product_qty"/>
    <field name="received" string="Printed"/>
</tree>
""", 'action': {'print_label': 'Print', 'cancel': 'Cancel'}})

view.add({'model': 'purchase.order', 'init': create_upload_button, 'mode': 'tree', 'string': False, 'arch': """
<tree>
    <field name="date"/>
    <field name="pl_from"/>
    <field name="pl_to"/>
    <field name="product_id"/>
    <field name="product_qty"/>
    <field name="boxes"/>
    <field name="received_qty"/>
    <field name="received_boxes"/>
    <field name="printed"/>
</tree>
""", 'action': {'print_label': 'Print'}})

view.add(model='purchase.order', mode='actual_receiving', arch="""
<tree-page title="Actual Receiving"/>
""", context={'actual_receiving': True})

view.add({'model': 'purchase.order', 'mode': 'form', 'string': False, 'arch': """
<form>
    <header>
        <button name="print_label" string="Print"/>
        <button name="receive" string="Receive" invisible="active_id.received == True"/>
    </header>
    <sheet>
        <group>
            <field name="name"/>
            <field name="part_no"/>
        </group>
        <group>
            <field name="product_qty"/>
            <field name="product_id"/>
        </group>
        <group>
            <field name="ps_month"/>
            <field name="pl_from"/>
        </group>
        <group>
            <field name="ps_code"/>
            <field name="pl_to"/>
        </group>
        <group width="100%">
            <field name="pack_ids">
                <tree>
                    <field name="product_id"/>
                    <field name="product_qty"/>
                    <field name="received"/>
                </tree>
            </field>
        </group>
    </sheet>
</form>
"""})

class PurchaseOrderPrint(models.Model):
    _name = 'purchase.order.print'

    supplier_id = fields.Many2one('purchase.order.supplier', string="Supplier")
    date_from = fields.Datetime(string="Date From")
    date_to = fields.Datetime(string="Date To")

    @async
    def print_label(self):
        args = []
        args.push(['date', '>=', self.date_from])
        args.push(['date', '<=', self.date_to])
        if self.supplier_id:
           supplier_id = await [self.env['purchase.order.supplier'].browse(self.supplier_id)]
           args.push(['pl_from', '=', supplier_id.name])
        order_ids = await [self.env['purchase.order'].search(*args)]
        return order_ids.print_label()

PurchaseOrderPrint()

menu.add({'id': 'purchase_order_print', 'parent': 'mrp_planning', 'string': 'Purchase Order Print', 'model': 'purchase.order.print', 'view_id': 'purchase.order.print.wizard', 'sequence': 11})

view.add(model='purchase.order.print', mode='wizard', arch="""
<form>
    <sheet>
        <group>
            <field name="date_from"/>
            <field name="supplier_id"/>
        </group>
        <group>
            <field name="date_to"/>
        </group>
        <group>
            <button name="print_label" string="Print"/>
        </group>
    </sheet>
</form>
""")

class PurchaseOrderSupplier(models.Model):
    _name = 'purchase.order.supplier'

    name = fields.Char(string="Supplier Code", required=True, index=True)

PurchaseOrderSupplier()

class HPPMData(models.Model):
    _name = 'hppm.data'

    @api.server
    def _get_number(self):
        return self.env['hppm.data'].with_context(order='name desc', limit=1).search(['name', '!=', False]).then(
        def (data_id):
            if data_id.length > 0:
               name = 'Data ' + str.zfill((parseInt(data_id.name.split(' ')[1]) + 1).toString(), 3)
               return name
            return 'Data 001'
        )

    def _get_type(self):
         if v'typeof window' != 'undefined':
            return window.models.env.context.default_import_type or None

    name = fields.Char(string="Data Number", defaults=_get_number, required=True)
    date = fields.Datetime(string="Date", defaults=tools.date.now)
    excel = fields.Binary(string="Excel Data", required=True, protect=True)
    imported = fields.Boolean(string="Uploaded")
    type = fields.Selection(['bom', 'Bill of Materials'], ['data_packing', 'Master Data Packing'], ['daisha_mcvt', 'Fitting MCVT'], ['daisha_fwd', 'Fitting 4WD'], ['daisha_flexi', 'Fitting Flexi'], ['sequence_mcvt', 'Sequence MCVT'], ['sequence_fwd', 'Sequence 4WD'], ['sequence_flexi', 'Sequence Flexi'], ['po', 'Purchase Orders'], ['route_agv', 'Route AGV'], string="Type", required=True, defaults=_get_type)

    @async
    def download_excel(self):
        self.env['log.data'].log('Downloading', self.name, 'id:', self.id, 'model:', self._name)
        excel = await [self.get_excel()]
        request = await [window.fetch('data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,' + excel)]
        blob = await [request.blob()]
        window.open(URL.createObjectURL(blob))

    @api.server
    def get_excel(self):
        return self.excel

    @async
    def import_data_client(self):
        self.env['log.data'].log('Uploading', self.name, 'type:', self.type, 'id:', self.id, 'model:', self._name)
        await [self.import_data()]
        return tools.dialog.alert('Upload Successful')

    @api.server
    def import_data(self):
        def after_finish():
            return self.write({'imported': True})
        if self.type == 'po': return self.import_po().then(after_finish)
        if self.type == 'bom': return self.import_bom().then(after_finish)
        if self.type == 'daisha_mcvt': return self.import_daisha('mcvt').then(after_finish)
        if self.type == 'daisha_fwd': return self.import_daisha('fwd').then(after_finish)
        if self.type == 'daisha_flexi': return self.import_daisha('flexi').then(after_finish)
        if self.type == 'sequence_mcvt': return self.import_sequence('mcvt').then(after_finish)
        if self.type == 'sequence_fwd': return self.import_sequence('fwd').then(after_finish)
        if self.type == 'sequence_flexi': return self.import_sequence('flexi').then(after_finish)
        if self.type == 'data_packing': return self.import_data_packing().then(after_finish)
        if self.type == 'route_agv': return self.import_route().then(after_finish)

    @api.server #(async=True)
    def import_route(self):
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[0]
        row = -1
        promises = []
        for data in sheet.data:
            row += 1
            if row == 0: continue
            promise = self.env['agv.route'].create({'name': data[3], 'picking_zone': data[2], 'fitting': data[1]})
            promises.push(promise)
        return Promise.all(promises)

    @api.server(async=True)
    def import_daisha(self, type):
        promises = []
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[0]
        row = -1
        trolleys = {}
        trolley_map = {}
        trolley_type = None
        @async
        def get_trolley(trolley_type, type):
            trolley_id = await [self.env['stock.trolley.type'].search(['name', '=', trolley_type], ['type', '=', type])]
            if not trolley_id.length:
               trolley_id = self.env['stock.trolley.type'].create({'name': trolley_type, 'type': type})
            return trolley_id
        for data in sheet.data:
            row += 1
            if row < 4: continue
            #if not data[5] or data[5] == '-': continue
            part_code = data[4]
            part_qty = data[7] or 0
            box_qty = data[24] or 0
            if row == 4 and part_code and not data[21]: raise exceptions.ValidationError("Trolley Type Empty")
            if data[21] and data[21] != trolley_type:
               if not trolley_type:
                  trolley_type = data[21]
                  if not trolleys[trolley_type]: trolleys[trolley_type] = {}
                  if not data[5] or data[5] == '-': continue
                  trolleys[trolley_type][part_code] = [part_qty, box_qty]
               else:
                  trolley_id = get_trolley(trolley_type, type)
                  product_ids = self.env['product.product']
                  products = []
                  @async
                  def check_part(code):
                      product_id = await [self.env['product.product'].search(['code', '=', code])]
                      if not product_id.length: raise exceptions.ValidationError("Part Number " + code + " is missing")
                      return product_id
                  for code in Object.keys(trolleys[trolley_type]):
                      products.push(check_part(code))
                  products = await (products)
                  for product_id in products:
                      product_ids.add(product_id)
                  trolley_id = await (trolley_id)
                  for product_id in product_ids:
                      product_id[type + '_trolley_type_id'] = trolley_id.id
                      product_id.qty_box,  product_id.min_box = trolleys[trolley_type][product_id.code] or [0, 0]
                  await [product_ids.write()] #{'trolley_type_id': trolley_id.id})]
                  #trolley_map[trolley_type] = product_ids.ids
                  del trolleys[trolley_type]
                  trolley_type = data[21]
                  if not trolleys[trolley_type]: trolleys[trolley_type] = {}
                  if not data[5] or data[5] == '-': continue
                  trolleys[trolley_type][part_code] = [part_qty, box_qty]
            elif trolley_type:
               if not trolleys[trolley_type]: trolleys[trolley_type] = {}
               if not data[5] or data[5] == '-': continue
               trolleys[trolley_type][part_code] = [part_qty, box_qty]
        for trolley in trolleys:
            trolley_id = get_trolley(trolley, type)
            #product_ids = await (self.env['product.product'].search(['code', 'in', Object.keys(trolleys[trolley])]))
            product_ids = self.env['product.product']
            products = []
            @async
            def check_part(code):
                product_id = await [self.env['product.product'].search(['code', '=', code])]
                if not product_id.length: raise exceptions.ValidationError("Part Number " + code + " is missing")
                return product_id
            for code in Object.keys(trolleys[trolley_type]):
                products.push(check_part(code))
            products = await (products)
            for product_id in products:
                product_ids.add(product_id)
            trolley_id = await (trolley_id)
            await (product_ids.write({type + '_trolley_type_id': trolley_id.id}))
            for product_id in product_ids:
                product_id[type + '_trolley_type_id'] = trolley_id.id
                product_id.qty_box, product_id.min_box = trolleys[trolley][product_id.code] or [0, 0]
            await [product_ids.write()] #{'trolley_type_id': trolley_id.id})]


    @api.server(async=True)
    def import_bom(self):
        promises = []
        xlsx = require('node-xlsx')
        sheets = xlsx.parse(tools.atob(self.excel, buffer=True))
        #row = -1
        models = {}
        models_code = {}
        models_promise = {}
        bom_promise = {}
        parts = {}
        @async
        def check_part(value):
            product_id = await (self.env['product.product'].search(['code', '=', value.code], ['type', '=', value.type]))
            if not product_id.length:
               product_id = await (self.env['product.product'].create(value))
            if not parts[value.type]: parts[value.type] = {}
            parts[value.type][value.code] = product_id
        for type, sheet in Object.entries({'ckd': sheets[0], 'local': sheets[1], 'inhouse': sheets[2]}):
            row = 0
            for data in sheet.data:
                row += 1
                if row < 11: continue
                if not data[1]: continue
                value = {'base_name': data[2], 'name': data[1] + ' - ' + data[2], 'code': data[1], 'code_trimmed': data[1].split(' ').join('').split('-').join(''), 'type': type}
                if not value.name or not value.code: continue
                promise = check_part(value)
                cell_index = -1
                for cell in data:
                    cell_index += 1
                    if cell_index < 5: continue
                    if not cell or cell == '-' or cell == '0': continue
                    model = [sheet.data[index][cell_index] for index in range(5, 11)].join(' ')
                    code = sheet.data[9][cell_index] + '-' + sheet.data[10][cell_index]
                    if not models[model]: models[model] = {}
                    if not models[model][type]: models[model][type] = {}
                    models[model][type][value.code] = cell
                    models_code[model] = code
                await (promise)
                #promises.push(promise)
            #await (promises)
        #promises = []
        @async
        def create_bom_line(bom_id, part, qty, type):
            product_id = parts[type][part]
            bom_line_id = await (self.env['mrp.bom.line'].search(['bom_id', '=', bom_id.id], ['product_id', '=', product_id.id]))
            if not bom_line_id.length:
               bom_line_id = await (self.env['mrp.bom.line'].create({'product_id': product_id.id, 'product_qty': qty, 'bom_id': bom_id.id}))
               return
            if bom_line_id.product_qty != qty: return bom_line_id.write({'product_qty': qty})
        @async
        def create_product(model, code):
            product_id = await [self.env['product.product'].search(['code', '=', code], ['type', '=', 'fg'])]
            if not product_id.length:
               product_id = await [self.env['product.product'].create({'base_name': model.split(' ').slice(0, -2).join(' '), 'name': model.trim(), 'code': code, 'type': 'fg'})]
            return product_id
        @async
        def create_bom(model, product_id):
            bom_id = await [self.env['mrp.bom'].search(['product_id', '=', product_id.id])]
            if not bom_id.length:
               bom_id = await [self.env['mrp.bom'].create({'name': model, 'product_id': product_id.id})]
            return bom_id
        @async
        def create_model(model, type, parts):
            code = models_code[model]
            promises = []
            if not models_promise[code]:
               models_promise[code] = create_product(model, code)
            product_id = await (models_promise[code])
            if not bom_promise[product_id.id]:
               bom_promise[product_id.id] = create_bom(model, product_id)
            bom_id = await (bom_promise[product_id.id])
            for part in parts:
                await (create_bom_line(bom_id, part, parts[part], type))
            #return Promise.all(promises)
        #promises = []
        for model in models:
            promises = []
            for type in models[model]:
                #await (create_model(model, type, models[model][type]))
                promises.push(create_model(model, type, models[model][type]))
            await (promises)
        #return self.write({'imported': True})

    @api.server(async=True)
    def import_sequence(self, type):
        promises = []
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[0]
        row = -1
        products = {}
        @async
        def create_picking_list(code, quantity, lot_no, sequence, date, type):
            date_object = new Date('1899-12-30 00:00:00')
            date_object.setDate(date_object.getDate() + parseInt(date))
            date = date_object
            product_id = await (self.env['product.product'].search(['code', '=', code], ['type', '=', 'fg']))
            if not product_id.length: raise exceptions.ValidationError("Model Number " + code + " is missing")
            bom_id = await (self.env['mrp.bom'].search(['product_id', '=', product_id.id]))
            if not bom_id.length: raise exceptions.ValidationError("Bill of Materials for Model Number " + code + " is missing")
            bom_line_ids, sequence_id = await ([self.env['mrp.bom.line'].browse(bom_id.line_ids), self.env['mrp.sequence'].create({'name': lot_no, 'sequence': sequence, 'type': type, 'date': date, 'bom_id': bom_id.id, 'quantity': quantity, 'destination': code.split('-')[1]})])
            promises = []
            routes = {index: 0 for index in range(1, 6)}
            trolley_group = {}
            for bom_line_id in bom_line_ids:
                product_id = products[bom_line_id.product_id]
                if not product_id:
                   product_id = await [self.env['product.product'].browse(bom_line_id.product_id)]
                   products[product_id.id] = product_id
                if not trolley_group[product_id[type + '_trolley_type_id']]:
                   if not product_id[type + '_trolley_type_id']: continue
                   trolley_group[product_id[type + '_trolley_type_id']] = await (self.env['stock.picking.list'].create({'model_id': bom_id.id, 'sequence_id': sequence_id.id, 'trolley_type_id': product_id[type + '_trolley_type_id'], 'sequence': sequence, 'date': date, 'type': type, 'part_type': product_id.type}))
                list_id = trolley_group[product_id[type + '_trolley_type_id']]
                if list_id.part_type != product_id.type and product_id.type == 'local':
                   list_id.write({'part_type': product_id.type})
                line_qty = bom_line_id.product_qty * quantity
                box = Math.ceil(line_qty / product_id.qty_box)
                promise = self.env['stock.picking.list.line'].create({'route': 1, 'product_id': bom_line_id.product_id, 'actual_qty': line_qty, 'qty_box': product_id.qty_box, 'min_box': product_id.min_box, 'part_no': product_id.code, 'actual_box': box, 'picking_list_id': list_id.id, 'sequence': sequence, 'date': date})
                promises.push(promise)
            return await (promises)
        for data in sheet.data:
            row += 1
            if row < 6: continue
            if not data[0] or not data[1]: continue
            valid_sequence = False
            try:
                if not isNaN(parseInt(data[1])): valid_sequence = True
            except:
                pass
            if not valid_sequence: continue
            head = 0
            """original_type = type
            if type == 'flexi':
               head = 1
               type = data[1].toLowerCase()"""
            lot_no = data.slice(head + 9, head + 14).join('-')
            promise = create_picking_list(data[head + 3] + '-' + data[head + 15], data[head + 2], lot_no, data[head + 1], data[0], type) #, original_type)
            await (promise)
            #promises.push(promise)
        #await (promises)
        #return self.write({'imported': True})

    @api.server(async=True)
    def import_po(self):
        promises = []
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[0]
        row = -1
        suppliers = {}
        suppliers_loaded = False
        @async
        def create_suppliers(supplier):
            if not suppliers_loaded:
               supplier_ids = await [self.env['purchase.order.supplier'].search()]
               for supplier_id in supplier_ids:
                   suppliers[supplier_id.name] = True
               nonlocal suppliers_loaded
               suppliers_loaded = True
            if supplier not in suppliers:
               self.env['purchase.order.supplier'].create({'name': supplier})
               suppliers[supplier] = True
        @async
        def create_po(value):
            create_suppliers(value.pl_from)
            order_id = await [self.env['purchase.order'].search(['part_no', '=', value.part_no], ['date_string', '=', value.date_string], ['ps_month', '=', value.ps_month], ['ps_code', '=', value.ps_code], ['pl_from', '=', value.pl_from], ['pl_to', '=', value.pl_to])]
            if order_id.length:
               return order_id.recompute_pack(value.product_qty)
            product_id = await (self.env['product.product'].search(['code_trimmed', '=', value.part_no], ['type', 'in', ('local', 'sozai')]))
            if not product_id.length: raise exceptions.ValidationError("Part Number " + value.part_no + " is missing")
            value.product_id = product_id.id
            order_id = await [self.env['purchase.order'].create(value)] #{'product_id': product_id.id, 'product_qty': value.quantity, 'vendor': value.vendor})
            order_id.compute_pack()
        for data in sheet.data:
            row += 1
            if row < 1: continue
            #if not data[0]: continue
            date = data[7] #.split('/')
            if date and type(date) == Number:
               date_object = new Date('1899-12-30 00:00:00')
               date_object.setDate(date_object.getDate() + parseInt(date))
               date_object.setMonth(date_object.getDate() - 1, date_object.getMonth() + 1)
               date = date_object
            else: date = new Date(date.split('/').reverse().join('-'))
            date_string = [date.getDate(), date.getMonth() + 1, date.getFullYear()].join('/')
            ps_month = date.toDateString().split(' ')[1] + '-' + date.getDate().toString()
            value = {'part_no': data[4].split(' ').join(''), 'product_qty': data[10], 'ps_month': ps_month, 'ps_code': data[1], 'pl_from': data[2], 'pl_to': data[3], 'date_string': date_string, 'date': date, 'lot_no': data[12] or ''}
            await [create_po(value)]
        #return Promise.all(promises)

    @api.server(async=True)
    def import_data_packing(self):
        promises = []
        xlsx = require('node-xlsx')
        sheets = xlsx.parse(tools.atob(self.excel, buffer=True))
        row = -1
        @async
        def create_part_sozai(value):
            product_id = await (self.env['product.product'].search(['code', '=', value.code], ['type', '=', 'sozai']))
            if product_id.length: return
            return self.env['product.product'].create(value)
        for data in sheets[4].data:
            row += 1
            if row < 3: continue
            #if not data[0]: continue
            value = {'code': data[1], 'code_trimmed': data[1].split(' ').join('').split('-').join(''), 'name': data[1] + '-' + data[2], 'base_name': data[2], 'qty_box': data[9] or 0, 'pl_from': data[3], 'supplier': data[4], 'model_type': data[5], 'packing_type': data[6], 'c_code': data[7], 'qty_box': data[8], 'type': 'sozai'}
            await [create_part_sozai(value)]
        @async
        def update_part(value, type):
            product_id = await (self.env['product.product'].search(['code', '=', value.code], ['type', '=', type]))
            if not product_id.length: raise exceptions.ValidationError("Part Number " + value.code + " is missing")
            if product_id.qty_box: del value.qty_box
            return product_id.write(value)
        for type, sheet in Object.entries({'local': sheets[0], 'ckd': sheets[2], 'inhouse': sheets[3]}):
            row = -1
            for data in sheet.data:
                row += 1
                if row < 3: continue
                if not data[0]: continue
                value = {'code': data[1], 'pl_from': data[3], 'supplier': data[4], 'model_type': data[5], 'packing_type': data[6], 'c_code': data[7], 'qty_box': data[8] or 0}
                await [update_part(value, type)]

    @api.server(async=True)
    def import_po_old(self):
        promises = []
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[0]
        row = -1
        @async
        def create_po(value):
            product_id = await (self.env['product.product'].search(['code_trimmed', '=', value.part_no]))
            if not product_id.length: return
            return self.env['purchase.order'].create({'product_id': product_id.id, 'product_qty': value.quantity, 'vendor': value.vendor})
        for data in sheet.data:
            row += 1
            if row < 1: continue
            #if not data[0]: continue
            value = {'part_no': data[0].split(' ').join(''), 'quantity': data[1], 'vendor': data[2]}
            await [create_po(value)]
        #return Promise.all(promises)

HPPMData()

menu.add({'id': 'import_data', 'parent': 'hppm_data', 'string': 'Upload', 'model': 'hppm.data', 'sequence': 1})

view.add({'model': 'hppm.data', 'mode': 'tree', 'string': False, 'arch': """
<tree>
    <field name="name"/>
    <field name="date"/>
</tree>
"""})

view.add({'model': 'hppm.data', 'mode': 'form', 'string': False, 'arch': """
<form>
    <header>
        <button name="import_data_client" string="Upload" invisible="active_id.imported == True"/>
    </header>
    <sheet>
        <group>
            <field name="name"/>
            <field name="excel" invisible="active_id.id != null"/>
        </group>
        <group>
            <field name="date"/>
            <field name="type"/>
            <field name="imported" readonly="True"/>
        </group>
        <group invisible="active_id.id == null">
            <button name="download_excel" string="Download"/>
        </group>
    </sheet>
</form>
"""})

view.add(model='hppm.data', mode='homepage', arch="""
<page>
   <img src="homepage.jpg" style="height: 100%"/>
</page>
""")

class ChangePassword(models.Model):
    _name = 'change.password'

    def _trigger(self):
        if v'typeof window' == 'undefined': return
        interval = None
        def getValues():
            if not document.getElementById('hppm_current_password'):
               nonlocal interval
               clearInterval(interval)
            self.env.context.current_password = document.getElementById('hppm_current_password').querySelector('input').value
            self.env.context.new_password = document.getElementById('hppm_new_password').querySelector('input').value
            self.env.context.confirm_password = document.getElementById('hppm_confirm_password').querySelector('input').value
        interval = setInterval(getValues(), 0)

    trigger = fields.Char(string="Trigger", defaults=_trigger)

    @async
    def change_password(self):
        context = self.env.context
        if context.new_password != context.confirm_password: return tools.dialog.alert("New password doesn't match")
        result = await [self.change_password_server(self.env.user.id, btoa(context.current_password), btoa(context.new_password), btoa(context.confirm_password))]
        @async
        def reload():
            await [window.session_db.destroy()]
            href = window.location.origin + window.location.pathname
            window.location.href = href.substring(0, href.lastIndexOf('/')) + '/'
        window.localStorage.session_start_date = tools.date.now().toISOString()
        return tools.dialog.alert('Password changed', reload)

    @api.server(async=True)
    def change_password_server(self, uid, current, new_password, confirm):
        current, new_password, confirm = tools.atob(current), tools.atob(new_password), tools.atob(confirm)
        if new_password != confirm: raise exceptions.ValidationError("New password doesn't match")
        user_id = await [self.env['res.users'].browse(uid)]
        self.env['log.data'].create({'name': ['Changing Password', 'success:', user_id.password == current].join(' '), 'user_id': user_id.id})
        if user_id.password != current: raise exceptions.ValidationError('Wrong password')
        doc = await [db.get(db.rel.makeDocID({'type': user_id._name, 'id': user_id.id}))]
        doc.data.password = new_password
        return db.put(doc)

ChangePassword()

menu.add(id='settings_password', parent='settings', model='change.password', view_id='change.password.wizard', string="Change Password", sequence=2)

view.add(model='change.password', mode='wizard', arch="""
<form>
    <sheet>
        <group>
            <list>
                <list-input label="Current Password" type="password" id="hppm_current_password"/>
            </list>
        </group>
        <group>
            <list>
                <list-input label="New Password" type="password" id="hppm_new_password"/>
            </list>
            <list>
                <list-input label="Confirm Password" type="password" id="hppm_confirm_password"/>
            </list>
        </group>
        <group>
            <button name="change_password" string="Change"/>
        </group>
        <group invisible="true">
            <field name="trigger"/>
        </group>
    </sheet>
</form>
""")

class LogData(models.Model):
    _name = 'log.data'

    def _get_user(self):
        if v'typeof window' == 'undefined': return None
        return models.env.user.id

    def _get_platform(self):
        if v'typeof window' == 'undefined': return ''
        return window.navigator.platform

    name = fields.Char(string="Log", required=True, readonly=True)
    user_id = fields.Many2one('res.users', string="User", defaults=_get_user, readonly=True)
    date = fields.Datetime(string="Date", defaults=tools.date.now, readonly=True)
    platform = fields.Char(string="Platform", defaults=_get_platform, readonly=True)

    def log(self):
        log = Array.prototype.slice.call(arguments).join(' ')
        return self.create({'name': log})

LogData()

menu.add(id='log_data', parent='hppm_data', model='log.data', string='Log', sequence=10)

view.add(model='log.data', mode='tree', arch="""
<tree>
    <field name="name"/>
    <field name="date"/>
    <field name="user_id"/>
    <field name="platform"/>
</tree>
""")

view.add(model='log.data', mode='form', arch="""
<form>
    <sheet>
        <group>
            <field name="name"/>
            <field name="date"/>
        </group>
        <group>
            <field name="user_id"/>
            <field name="platform"/>
        </group>
    </sheet>
</form>
""")
