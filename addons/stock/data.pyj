import orm.models as models
import orm.fields as fields
import orm.tools as tools
import orm.api as api
import orm.exceptions as exceptions
from ir.ui import menu, view
from ir.sequence import add_sequence
from stock.location import defaults as location_defaults
from jasper.report import get_jasper_report
from utils import create_upload_button

class PurchaseOrder(models.Model):
    _name = 'purchase.order'

    def _get_boxes(self):
        return self.pack_ids.length

    name = fields.Char(string="PO Number")
    part_no = fields.Char(string="Part No.", index=True)
    product_id = fields.Many2one('product.product', string="Part", index=True)
    product_qty = fields.Float(string="Quantity")
    boxes = fields.Integer(string="Boxes", compute=_get_boxes, store=False)
    printed = fields.Boolean(string="Printed", index=True)
    ps_month = fields.Char(string="P/S Month", index=True)
    ps_code = fields.Char(string="P/S Code", index=True)
    pl_from = fields.Char(string="P/L From", index=True)
    pl_to = fields.Char(string="P/L To", index=True)
    pack_ids = fields.One2many('purchase.order.pack', 'order_id', string="Packs")
    date = fields.Datetime(string="Date", index=True)
    date_string = fields.Char(string="Date (String)", index=True)

    @async
    def create(self, values=False, is_client=tools.configuration.client):
        if v'typeof window' != 'undefined': return self.__super__('create')(values=values, is_client=is_client)
        values = values if tools.exist(values) else self.values
        for value in tools.each(values):
            sequence = await (self.env['ir.sequence'].get_next('purchase.order'))
            value.name = 'PO ' + str.zfill(sequence.toString(), 3)
        result = await (self.__super__('create')(values=values, is_client=is_client))
        return result

    def print_barcode(self):
        if v'typeof window' != 'undefined' and window.printBarcode:
           for record in self: printBarcode(record.name)

    @async
    def print_label(self):
     try:
        values = []
        for record in self:
            value = record.read()
            pack_ids = await [self.env['purchase.order.pack'].browse(record.pack_ids)]
            pack_values = await [pack_ids.read(format=True, without_null=True, relational_fields=['product_id'])]
            for pack_value in pack_values:
                for key in value:
                    if key not in pack_value: pack_value[key] = value[key]
            values.push(*pack_values)
        url = await [get_jasper_report('/Solu/HPPM/Purchase_Order', {'data': JSON.stringify(values)})]
        self.write({'printed': True})
        window.open(url)
     except Exception as error:
        alert(error.stack or error.message)

    def get_box_quantities(self, quantity, product_id):
        boxes = quantity / product_id.qty_box
        rounded_boxes = parseInt(boxes)
        box_quantities = [product_id.qty_box for index in range(rounded_boxes)]
        residual = boxes - rounded_boxes
        if residual != 0: box_quantities.push(quantity - (rounded_boxes * product_id.qty_box))
        return box_quantities

    @api.server(async=True)
    def compute_pack(self, quantity):
        product_id = await [self.env['product.product'].browse(self.product_id)]
        if not product_id.qty_box: return
        if not quantity: quantity = self.product_qty
        promises = []
        for box_quantity in self.get_box_quantities(quantity, product_id):
            promise = self.env['purchase.order.pack'].create({'name': self.name, 'order_id': self.id, 'part_no': self.part_no, 'product_id': self.product_id, 'product_qty': box_quantity})
        return await (promises)


    @api.server(async=True)
    def recompute_pack(self, quantity):
        if not self.printed:
           write = self.write({'product_qty': quantity})
           pack_ids = await [self.env['purchase.order.pack'].browse(self.pack_ids)]
           await (write)
           return await ([pack_ids.unlink(), self.compute_pack()])
        if quantity > self.product_qty:
           self.write({'product_qty': quantity})
           return self.compute_pack(quantity - self.product_qty)
        if quantity == self.product_qty: return
        product_id = await [self.env['product.product'].browse(self.product_id)]
        original_quantities = self.get_box_quantities(self.product_qty, product_id)
        new_quantities = self.get_box_quantities(self.product_qty - quantity, product_id)
        promises = [self.write({'product_qty': quantity})]
        for new_quantity in new_quantities:
            if new_quantity not in original_quantities: promises.push(self.env['purchase.order.pack'].create({'name': self.name, 'order_id': self.id, 'part_no': self.part_no, 'product_id': self.product_id, 'product_qty': new_quantity}))
        return await (promises)

PurchaseOrder()

pack_sequence = 0

class PurchaseOrderPack(models.Model):
    _name = 'purchase.order.pack'

    name = fields.Char(string="PO Number")
    part_no = fields.Char(string="Part No.")
    product_id = fields.Many2one('product.product', string="Part")
    product_qty = fields.Float(string="Quantity")
    order_id = fields.Many2one('purchase.order', string="Purchase Order")
    barcode = fields.Text(string="Barcode")
    received = fields.Boolean(string="Received")
    inhouse_ckd = fields.Boolean(string="Inhouse/CKD", index=True)
    ckd_id = fields.Many2one('stock.receive.ckd', string="Receiving CKD")

    @async
    def create(self, values=False, is_client=tools.configuration.client):
        if v'typeof window' == 'undefined': return self.__super__('create')(values=values, is_client=is_client)
        result = await [self.__super__('create')(values=values, is_client=is_client)]
        for record in result:
            await [record.write({'barcode': JSON.stringify(self.read())})]
        return result

    @async
    def print_label(self):
     try:
        values = await [self.read(format=True, without_null=True, relational_fields=['product_id'])]
        order_id = None
        po_value = None
        for value in values:
            if not po_value:
               order_id = await [self.env['purchase.order'].browse(self._values[0].order_id)]
               po_value = order_id.read()
            for key in po_value:
                if key not in value: value[key] = po_value[key] or ''
        url = await [get_jasper_report('/Solu/HPPM/Purchase_Order', {'data': JSON.stringify(values)})]
        if order_id: order_id.write({'printed': True})
        window.open(url)
     except Exception as error:
        alert(error.stack or error.message)

    @async
    def receive(self, immediate):
        pack_ids = []
        for record in self:
            if record.received: return tools.alert('One of the PO is already received')
        for record in self:
            nonlocal pack_sequence
            pack_sequence += 1
            if pack_sequence >= 10: pack_sequence = 1
            pack_id, order_id = await ([self.env['stock.pack'].create({'name': 'Pack ' + record.name.replace('PO ', '') + '-' + (pack_sequence + (new Date()).getMilliseconds()), 'product_id': record.product_id, 'product_qty': record.product_qty, 'order_pack_id': record.id}), record.write({'received': True})])
            pack_ids.push(pack_id.id)
        picking_id = await [self.env['stock.picking'].create({'location_src_id': location_defaults.external_id, 'location_dest_id': location_defaults.internal_id, 'type': 'putting', 'pack_ids': pack_ids})]
        if immediate:
           return picking_id.validate(immediate=True)
        tools.navigate('/form/stock.picking?id=' + picking_id.id)

PurchaseOrderPack()

add_sequence('purchase.order')

menu.add({'id': 'hppm_data', 'string': 'Data', 'sequence': 25})

menu.add({'id': 'hppm_po', 'parent': 'mrp_planning', 'string': 'Purchase Order', 'model': 'purchase.order', 'sequence': 10})

menu.add(id='receiving_print', parent='receiving', model='purchase.order.pack', string="Reprint Inhouse & CKD", sequence=5)

view.add({'model': 'purchase.order.pack', 'mode': 'tree', 'string': False, 'arch': """
<tree domain="['inhouse_ckd', '=', True]">
    <field name="name"/>
    <field name="product_id"/>
    <field name="product_qty"/>
</tree>
""", 'action': {'print_label': 'Print'}})

view.add({'model': 'purchase.order', 'init': create_upload_button, 'mode': 'tree', 'string': False, 'arch': """
<tree>
    <field name="date_string"/>
    <field name="pl_from"/>
    <field name="pl_to"/>
    <field name="product_id"/>
    <field name="product_qty"/>
    <field name="boxes"/>
    <field name="printed"/>
</tree>
""", 'action': {'print_label': 'Print'}})

view.add({'model': 'purchase.order', 'mode': 'form', 'string': False, 'arch': """
<form>
    <header>
        <button name="print_label" string="Print"/>
        <button name="receive" string="Receive" invisible="active_id.received == True"/>
    </header>
    <sheet>
        <group>
            <field name="name"/>
            <field name="part_no"/>
        </group>
        <group>
            <field name="product_qty"/>
            <field name="product_id"/>
        </group>
        <group>
            <field name="ps_month"/>
            <field name="pl_from"/>
        </group>
        <group>
            <field name="ps_code"/>
            <field name="pl_to"/>
        </group>
        <group width="100%">
            <field name="pack_ids">
                <tree>
                    <field name="product_id"/>
                    <field name="product_qty"/>
                    <field name="received"/>
                </tree>
            </field>
        </group>
    </sheet>
</form>
"""})

class PurchaseOrderPrint(models.Model):
    _name = 'purchase.order.print'

    supplier_id = fields.Many2one('purchase.order.supplier', string="Supplier")
    date_from = fields.Datetime(string="Date From")
    date_to = fields.Datetime(string="Date To")

    @async
    def print_label(self):
        args = []
        args.push(['date', '>=', self.date_from])
        args.push(['date', '<=', self.date_to])
        if self.supplier_id:
           supplier_id = await [self.env['purchase.order.supplier'].browse(self.supplier_id)]
           args.push(['pl_from', '=', supplier_id.name])
        order_ids = await [self.env['purchase.order'].search(*args)]
        return order_ids.print_label()

PurchaseOrderPrint()

menu.add({'id': 'purchase_order_print', 'parent': 'mrp_planning', 'string': 'Purchase Order Print', 'model': 'purchase.order.print', 'view_id': 'purchase.order.print.wizard', 'sequence': 11})

view.add(model='purchase.order.print', mode='wizard', arch="""
<form>
    <sheet>
        <group>
            <field name="date_from"/>
            <field name="supplier_id"/>
        </group>
        <group>
            <field name="date_to"/>
        </group>
        <group>
            <button name="print_label" string="Print"/>
        </group>
    </sheet>
</form>
""")

class PurchaseOrderSupplier(models.Model):
    _name = 'purchase.order.supplier'

    name = fields.Char(string="Supplier Code", required=True, index=True)

PurchaseOrderSupplier()

class HPPMData(models.Model):
    _name = 'hppm.data'

    @api.server
    def _get_number(self):
        return self.env['hppm.data'].with_context(order='name desc', limit=1).search(['name', '!=', False]).then(
        def (data_id):
            if data_id.length > 0:
               name = 'Data ' + str.zfill((parseInt(data_id.name.split(' ')[1]) + 1).toString(), 3)
               return name
            return 'Data 001'
        )

    def _get_type(self):
         if v'typeof window' != 'undefined':
            return window.models.env.context.default_import_type or None

    name = fields.Char(string="Data Number", defaults=_get_number, required=True)
    date = fields.Datetime(string="Date", defaults=tools.date.now)
    excel = fields.Binary(string="Excel Data", required=True, protect=True)
    imported = fields.Boolean(string="Uploaded")
    type = fields.Selection(['bom', 'Bill of Materials'], ['sozai', 'Parts Sozai'], ['daisha_mcvt', 'Fitting MCVT'], ['daisha_fwd', 'Fitting 4WD'], ['daisha_flexi', 'Fitting Flexi'], ['sequence_mcvt', 'Sequence MCVT'], ['sequence_fwd', 'Sequence 4WD'], ['sequence_flexi', 'Sequence Flexi'], ['po', 'Purchase Orders'], string="Type", required=True, defaults=_get_type)

    @async
    def download_excel(self):
        excel = await [self.get_excel()]
        request = await [window.fetch('data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,' + excel)]
        blob = await [request.blob()]
        window.open(URL.createObjectURL(blob))

    @api.server
    def get_excel(self):
        return self.excel

    @async
    def import_data_client(self):
        await [self.import_data()]
        return tools.dialog.alert('Upload Successful')

    @api.server
    def import_data(self):
        def after_finish():
            return self.write({'imported': True})
        if self.type == 'po': return self.import_po().then(after_finish)
        if self.type == 'bom': return self.import_bom().then(after_finish)
        if self.type == 'daisha_mcvt': return self.import_daisha('mcvt').then(after_finish)
        if self.type == 'daisha_fwd': return self.import_daisha('fwd').then(after_finish)
        if self.type == 'daisha_flexi': return self.import_daisha('flexi').then(after_finish)
        if self.type == 'sequence_mcvt': return self.import_sequence('mcvt').then(after_finish)
        if self.type == 'sequence_fwd': return self.import_sequence('fwd').then(after_finish)
        if self.type == 'sequence_flexi': return self.import_sequence('flexi').then(after_finish)
        if self.type == 'sozai': return self.import_sozai().then(after_finish)

    @api.server(async=True)
    def import_daisha(self, type):
        promises = []
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[0]
        row = -1
        trolleys = {}
        trolley_map = {}
        trolley_type = None
        @async
        def get_trolley(trolley_type, type):
            trolley_id = await [self.env['stock.trolley.type'].search(['name', '=', trolley_type], ['type', '=', type])]
            if not trolley_id.length:
               trolley_id = self.env['stock.trolley.type'].create({'name': trolley_type, 'type': type})
            return trolley_id
        for data in sheet.data:
            row += 1
            if row < 4: continue
            #if not data[5] or data[5] == '-': continue
            part_code = data[4]
            part_qty = data[7]
            if data[21] and data[21] != trolley_type:
               if not trolley_type:
                  trolley_type = data[21]
                  if not trolleys[trolley_type]: trolleys[trolley_type] = {}
                  if not data[5] or data[5] == '-': continue
                  trolleys[trolley_type][part_code] = part_qty
               else:
                  trolley_id = get_trolley(trolley_type, type)
                  product_ids = await [self.env['product.product'].search(['code', 'in', Object.keys(trolleys[trolley_type])])]
                  trolley_id = await (trolley_id)
                  for product_id in product_ids:
                      product_id[type + '_trolley_type_id'] = trolley_id.id
                      product_id.qty_box = trolleys[trolley_type][product_id.code] or 0
                  await [product_ids.write()] #{'trolley_type_id': trolley_id.id})]
                  #trolley_map[trolley_type] = product_ids.ids
                  del trolleys[trolley_type]
                  trolley_type = data[21]
                  if not trolleys[trolley_type]: trolleys[trolley_type] = {}
                  if not data[5] or data[5] == '-': continue
                  trolleys[trolley_type][part_code] = part_qty
            elif trolley_type:
               if not trolleys[trolley_type]: trolleys[trolley_type] = {}
               if not data[5] or data[5] == '-': continue
               trolleys[trolley_type][part_code] = part_qty
        for trolley in trolleys:
            trolley_id = get_trolley(trolley, type)
            product_ids = await (self.env['product.product'].search(['code', 'in', Object.keys(trolleys[trolley])]))
            trolley_id = await (trolley_id)
            await (product_ids.write({type + '_trolley_type_id': trolley_id.id}))
            for product_id in product_ids:
                product_id[type + '_trolley_type_id'] = trolley_id.id
                product_id.qty_box = trolleys[trolley][product_id.code] or 0
            await [product_ids.write()] #{'trolley_type_id': trolley_id.id})]


    @api.server(async=True)
    def import_bom(self):
        promises = []
        xlsx = require('node-xlsx')
        sheets = xlsx.parse(tools.atob(self.excel, buffer=True))
        #row = -1
        models = {}
        models_code = {}
        models_promise = {}
        bom_promise = {}
        parts = {}
        @async
        def check_part(value):
            product_id = await (self.env['product.product'].search(['code', '=', value.code], ['type', '=', value.type]))
            if not product_id.length:
               product_id = await (self.env['product.product'].create(value))
            if not parts[value.type]: parts[value.type] = {}
            parts[value.type][value.code] = product_id
        for type, sheet in Object.entries({'ckd': sheets[0], 'local': sheets[1], 'inhouse': sheets[2]}):
            row = 0
            for data in sheet.data:
                row += 1
                if row < 11: continue
                if not data[1]: continue
                value = {'base_name': data[1], 'name': data[1] + ' - ' + data[2], 'code': data[1], 'code_trimmed': data[1].split(' ').join('').split('-').join(''), 'type': type}
                if not value.name or not value.code: continue
                promise = check_part(value)
                cell_index = -1
                for cell in data:
                    cell_index += 1
                    if cell_index < 5: continue
                    if not cell or cell == '-' or cell == '0': continue
                    model = [sheet.data[index][cell_index] for index in range(5, 11)].join(' ')
                    code = sheet.data[9][cell_index] + '-' + sheet.data[10][cell_index]
                    if not models[model]: models[model] = {}
                    if not models[model][type]: models[model][type] = {}
                    models[model][type][value.code] = cell
                    models_code[model] = code
                await (promise)
                #promises.push(promise)
            #await (promises)
        #promises = []
        @async
        def create_bom_line(bom_id, part, qty, type):
            product_id = parts[type][part]
            bom_line_id = await (self.env['mrp.bom.line'].search(['bom_id', '=', bom_id.id], ['product_id', '=', product_id.id]))
            if not bom_line_id.length:
               bom_line_id = await (self.env['mrp.bom.line'].create({'product_id': product_id.id, 'product_qty': qty, 'bom_id': bom_id.id}))
               return
            if bom_line_id.product_qty != qty: return bom_line_id.write({'product_qty': qty})
        @async
        def create_product(model, code):
            product_id = await [self.env['product.product'].search(['code', '=', code], ['type', '=', 'fg'])]
            if not product_id.length:
               product_id = await [self.env['product.product'].create({'base_name': model.split(' ').slice(0, -2).join(' '), 'name': model, 'code': code, 'type': 'fg'})]
            return product_id
        @async
        def create_bom(model, product_id):
            bom_id = await [self.env['mrp.bom'].search(['product_id', '=', product_id.id])]
            if not bom_id.length:
               bom_id = await [self.env['mrp.bom'].create({'name': model, 'product_id': product_id.id})]
            return bom_id
        @async
        def create_model(model, type, parts):
            code = models_code[model]
            promises = []
            if not models_promise[code]:
               models_promise[code] = create_product(model, code)
            product_id = await (models_promise[code])
            if not bom_promise[product_id.id]:
               bom_promise[product_id.id] = create_bom(model, product_id)
            bom_id = await (bom_promise[product_id.id])
            for part in parts:
                await (create_bom_line(bom_id, part, parts[part], type))
            #return Promise.all(promises)
        #promises = []
        for model in models:
            promises = []
            for type in models[model]:
                #await (create_model(model, type, models[model][type]))
                promises.push(create_model(model, type, models[model][type]))
            await (promises)
        #return self.write({'imported': True})

    @api.server(async=True)
    def import_sequence(self, type):
        promises = []
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[0]
        row = -1
        products = {}
        @async
        def create_picking_list(code, quantity, lot_no, sequence, date, type):
            product_id = await (self.env['product.product'].search(['code', '=', code], ['type', '=', 'fg']))
            bom_id = await (self.env['mrp.bom'].search(['product_id', '=', product_id.id]))
            bom_line_ids, sequence_id = await ([self.env['mrp.bom.line'].browse(bom_id.line_ids), self.env['mrp.sequence'].create({'name': lot_no, 'sequence': sequence, 'type': type, 'date': date, 'bom_id': bom_id.id, 'quantity': quantity, 'destination': code.split('-')[1]})])
            promises = []
            routes = {index: 0 for index in range(1, 6)}
            trolley_group = {}
            for bom_line_id in bom_line_ids:
                product_id = products[bom_line_id.product_id]
                if not product_id:
                   product_id = await [self.env['product.product'].browse(bom_line_id.product_id)]
                   products[product_id.id] = product_id
                if not trolley_group[product_id[type + '_trolley_type_id']]:
                   if not product_id[type + '_trolley_type_id']: continue
                   trolley_group[product_id[type + '_trolley_type_id']] = await (self.env['stock.picking.list'].create({'model_id': bom_id.id, 'sequence_id': sequence_id.id, 'trolley_type_id': product_id[type + '_trolley_type_id'], 'sequence': sequence, 'date': date, 'type': type}))
                list_id = trolley_group[product_id[type + '_trolley_type_id']]
                line_qty = bom_line_id.product_qty * quantity
                box = Math.ceil(line_qty / product_id.qty_box)
                promise = self.env['stock.picking.list.line'].create({'route': 1, 'product_id': bom_line_id.product_id, 'actual_qty': line_qty, 'qty_box': product_id.qty_box, 'part_no': product_id.code, 'actual_box': box, 'picking_list_id': list_id.id, 'sequence': sequence, 'date': date})
                promises.push(promise)
            return await (promises)
        for data in sheet.data:
            row += 1
            if row < 6: continue
            if not data[0]: continue
            head = 0
            """original_type = type
            if type == 'flexi':
               head = 1
               type = data[1].toLowerCase()"""
            lot_no = data.slice(head + 9, head + 14).join('-')
            promise = create_picking_list(data[head + 3] + '-' + data[head + 15], data[head + 2], lot_no, data[head + 1], new Date(data[0]), type) #, original_type)
            await (promise)
            #promises.push(promise)
        #await (promises)
        #return self.write({'imported': True})

    @api.server(async=True)
    def import_po(self):
        promises = []
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[0]
        row = -1
        suppliers = {}
        suppliers_loaded = False
        @async
        def create_suppliers(supplier):
            if not suppliers_loaded:
               supplier_ids = await [self.env['purchase.order.supplier'].search()]
               for supplier_id in supplier_ids:
                   suppliers[supplier_id.name] = True
               nonlocal suppliers_loaded
               suppliers_loaded = True
            if supplier not in suppliers:
               self.env['purchase.order.supplier'].create({'name': supplier})
               suppliers[supplier] = True
        @async
        def create_po(value):
            create_suppliers(value.pl_from)
            order_id = await [self.env['purchase.order'].search(['part_no', '=', value.part_no], ['date_string', '=', value.date_string], ['ps_month', '=', value.ps_month], ['ps_code', '=', value.ps_code], ['pl_from', '=', value.pl_from], ['pl_to', '=', value.pl_to])]
            if order_id.length:
               return order_id.recompute_pack(value.product_qty)
            product_id = await (self.env['product.product'].search(['code_trimmed', '=', value.part_no], ['type', 'in', ('local', 'sozai')]))
            if not product_id.length: return
            value.product_id = product_id.id
            order_id = await [self.env['purchase.order'].create(value)] #{'product_id': product_id.id, 'product_qty': value.quantity, 'vendor': value.vendor})
            order_id.compute_pack()
        for data in sheet.data:
            row += 1
            if row < 1: continue
            #if not data[0]: continue
            date = data[7].split('/')
            value = {'part_no': data[4].split(' ').join(''), 'product_qty': data[10], 'ps_month': data[0], 'ps_code': data[1], 'pl_from': data[2], 'pl_to': data[3], 'date_string': data[7], 'date': new Date(date[1] + '/' + date[0] + '/' + date[2])}
            await [create_po(value)]
        #return Promise.all(promises)

    @api.server(async=True)
    def import_sozai(self):
        promises = []
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[4]
        row = -1
        @async
        def create_part(value):
            product_id = await (self.env['product.product'].search(['code', '=', value.code], ['type', '=', 'sozai']))
            if product_id.length: return
            return self.env['product.product'].create(value)
        for data in sheet.data:
            row += 1
            if row < 3: continue
            #if not data[0]: continue
            value = {'code': data[1], 'code_trimmed': data[1].split(' ').join('').split('-').join(''), 'name': data[1] + '-' + data[2], 'base_name': data[2], 'qty_box': data[9], 'vendor': data[4], 'type': 'sozai'}
            await [create_part(value)]
        #return Promise.all(promises)

    @api.server(async=True)
    def import_po_old(self):
        promises = []
        xlsx = require('node-xlsx')
        sheet = xlsx.parse(tools.atob(self.excel, buffer=True))[0]
        row = -1
        @async
        def create_po(value):
            product_id = await (self.env['product.product'].search(['code_trimmed', '=', value.part_no]))
            if not product_id.length: return
            return self.env['purchase.order'].create({'product_id': product_id.id, 'product_qty': value.quantity, 'vendor': value.vendor})
        for data in sheet.data:
            row += 1
            if row < 1: continue
            #if not data[0]: continue
            value = {'part_no': data[0].split(' ').join(''), 'quantity': data[1], 'vendor': data[2]}
            await [create_po(value)]
        #return Promise.all(promises)

HPPMData()

menu.add({'id': 'import_data', 'parent': 'hppm_data', 'string': 'Upload', 'model': 'hppm.data', 'sequence': 1})

view.add({'model': 'hppm.data', 'mode': 'tree', 'string': False, 'arch': """
<tree>
    <field name="name"/>
    <field name="date"/>
</tree>
"""})

view.add({'model': 'hppm.data', 'mode': 'form', 'string': False, 'arch': """
<form>
    <header>
        <button name="import_data_client" string="Upload" invisible="active_id.imported == True"/>
    </header>
    <sheet>
        <group>
            <field name="name"/>
            <field name="excel" invisible="active_id.id != null"/>
        </group>
        <group>
            <field name="date"/>
            <field name="type"/>
            <field name="imported" readonly="True"/>
        </group>
        <group invisible="active_id.id == null">
            <button name="download_excel" string="Download"/>
        </group>
    </sheet>
</form>
"""})

class ChangePassword(models.Model):
    _name = 'change.password'

    @async
    def change_password(self):
        new_password = document.getElementById('hppm_new_password').value
        confirm_password = document.getElementById('hppm_confirm_password').value
        if new_password != confirm_password: return tools.dialog.alert("New password doesn't match")
        result = await [self.change_password_server(self.env.user.id, btoa(document.getElementById('hppm_current_password').value), btoa(new_password), btoa(confirm_password))]
        def reload():
            href = window.location.origin + window.location.pathname
            window.location.href = href.substring(0, href.lastIndexOf('/')) + '/'
        window.localStorage.session_start_date = tools.date.now().toISOString()
        return tools.dialog.alert('Password changed', reload)

    @api.server(async=True)
    def change_password_server(self, uid, current, new_password, confirm):
        current, new_password, confirm = tools.atob(current), tools.atob(new_password), tools.atob(confirm)
        if new_password != confirm: raise exceptions.ValidationError("New password doesn't match")
        user_id = await [self.env['res.users'].browse(uid)]
        if user_id.password != current: raise exceptions.ValidationError('Wrong password')
        doc = await [models.db.get(models.db.rel.makeDocID({'type': user_id._name, 'id': user_id.id}))]
        doc.password = new_password
        return models.db.put(doc)

ChangePassword()

menu.add(id='settings_password', parent='settings', model='change.password', view_id='change.password.wizard', string="Change Password", sequence=2)

view.add(model='change.password', mode='wizard', arch="""
<form>
    <sheet>
        <group>
            <list>
                <list-input label="Current Password" type="password" id="hppm_current_password"/>
            </list>
        </group>
        <group>
            <list>
                <list-input label="New Password" type="password" id="hppm_new_password"/>
            </list>
            <list>
                <list-input label="Confirm Password" type="password" id="hppm_confirm_password"/>
            </list>
        </group>
        <group>
            <button name="change_password" string="Change Password"/>
        </group>
    </sheet>
</form>
""")
