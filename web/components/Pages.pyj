import orm.models as models
import orm.tools as tools
import web.react as react
import web.components.Page
import web.components.Tree
import web.components.Form
import web.components.Header
import web.components.Button
import web.components.Sheet
import web.components.Group
import web.components.Field
import web.components.Footer

Page, Navbar, NavTitle, Block, Button, Link, List, ListItem, Icon, Toolbar, Tabs, Tab, p, div, ul, li, a = react.get_framework_components('Page', 'Navbar', 'NavTitle', 'Block', 'Button', 'Link', 'List', 'ListItem', 'Icon', 'Toolbar', 'Tabs', 'Tab', 'p', 'div', 'ul', 'li', 'a')

def HomePage(props):
    if models == undefined:
       return LoginPage();
    elif tools.configuration.home_view:
       mode = tools.configuration.home_view.split('.').slice(-1)[0];
       model = tools.configuration.home_view.split('.').slice(0, -1).join('.');
       models.env.context.active_mode = mode;
       models.env.context.active_model = model;
       if mode == 'tree':
          return TreePage()
       elif mode == 'form':
          return FormPage()
       elif mode != 'chat':
          return CustomPage()
  return
    Page(
      Navbar(
        NavTitle('Home')
      ),
      Block(strong=True,
        p("Here is your blank Framework7 app. Let's see what we have here")
      ),
    )

react.register_component(HomePage)

function_string =
"""if (!active_id) return false;
var context = models.env.context;
var True = true;
var False = false;
var None = null;
return """

def parseAttribute(props, element):
    for attribute in element.attributes:
        props[attribute.name] = attribute.value
    for attribute in ['invisible', 'required', 'readonly']:
        if attribute in props:
           if props[attribute] in ['true', 'True']: props[attribute] = True
           if props[attribute] in ['false', 'False']: props[attribute] = False
           if props[attribute].constructor == Boolean: continue
           props[attribute] = new (Function.prototype.bind.apply(Function, [null, 'active_id', function_string + props[attribute].replace(' == ', ' === ').replace(' != ', ' !== ')]))();
    if props.domain: props.domain = new (Function.prototype.bind.apply(Function, [null, 'active_id', function_string + '[' + props.domain + ']']))();

def parseTreeView(view, model, title) {
    Tree = react.get_components('Tree')
    customComponents = {'Tree': Tree, 'Field': None}
    view = new DOMParser().parseFromString(view, 'text/xml').children[0]
    console.log(view)
    if title: view.setAttribute('title', title)
    def recurse(elements, parent_props):
        components = []
        for element in elements:
            component = customComponents[element.tagName[0].toUpperCase() + element.tagName.toLowerCase().slice(1)] or customComponents[element.tagName] or element.tagName
            props = {'model': model, 'view_model': model}
            parseAttribute(element, props)
            props.isTreeView = True
            children = recurse(element.children, props) or [def render(): element.innerHTML]
            components.push(def render(): React.createElement(component, props, children.map(def (result): return result())))
        if not components.length: return None
        return components
    return recurse([view], true)[0]

cachedTreeViews = {}

class TreePage(React.Component):

    def componentDidMount(self):
        model = self.model
        mode = self.mode
        if tools.view[model].custom_init and tools.view[model].custom_init[model + '.' + mode]:
           tools.view[model].custom_init[model + '.' + mode].bind(self)(self.props)

    def render(self, props):
        model = models.env.context.active_model;
        if props.f7route and props.f7route.url: models.env.context.active_url = props.f7route.url
        else: models.env.context.active_url = '/'
        models.env.context.active_id = null
        if props.f7route and props.f7route.params and props.f7route.params.model:
           model = props.f7route.params.model
        mode = 'tree'
        self.model = model
        self.mode = mode
        view = tools.view[model].tree
        models.env.context.active_model = mode
        if not cachedTreeViews[view + ('-' + props.title if props.title else '')]):
           cachedTreeViews[view + ('-' + props.title if props.title else '')] = parseTreeView(view, model, props.title)
        return cachedTreeViews[view + ('-' + props.title if props.title else '')]()

react.register_component(TreePage)

def parseFormView(view, model):
    customComponents = client.components
    view = new DOMParser().parseFromString(view, 'text/xml').children[0]
    def recurse(elements, parent_props):
        components = []
        for element in elements:
            component = customComponents[element.tagName.split('-').map(def (word): return word[0].toUpperCase() + word.slice(1).toLowerCase()).join('')] if '-' in element.tagName else None or customComponents[element.tagName[0].toUpperCase() + element.tagName.toLowerCase().slice(1)] or customComponents[element.tagName] or element.tagName
            props = {'model': model}
            parseAttribute(element, props)
            if component == Tree:
               field = models.env[model]._fields[parent_props.name]
               props.view_model = model
               props.field_name = parent_props.name
               props.model = field.relation
               props.field = field.inverse if field.type == 'one2many' else parent_props.name
               if field.type != 'one2many':
                  props.parent_model = model
                  props.tree_arch = element.outerHTML
               if parent_props.invisible: props.invisible = parent_props.invisible
               if parent_props.domain: props.domain = parent_props.domain
            children = recurse(element.children, props) or [def render(): element.innerHTML]
            components.push(def render(): React.createElement(component, props, children.map(def (result): return result())))
        if not components.length: return None
        return components
    return recurse([view], True)[0]

cachedFormViews = {}

class FormPage(React.Component):

  def componentDidUpdate(self):
      if self.afterMount:
         del self.afterMount
         return
      model = self.model
      mode = self.mode
      if tools.view[model].custom_init and tools.view[model].custom_init[model + '.' + mode]:
         tools.view[model].custom_init[model + '.' + mode].bind(self)(self.props)

  def componentDidMount(self):
      self.componentDidUpdate()
      self.afterMount = True
      def wait():
          self.afterMount = False
      setTimeout(wait, 1000)

  def render(self, props):
      def refresh():
          return self.setState({})
      self.refresh = refresh
      models.env.context.refresh = refresh
      model = models.env.context.active_model
      if props.f7route and props.f7route.url: models.env.context.active_url = props.f7route.url
      else: models.env.context.active_url = '/'
      if props.f7route and props.f7route.params and props.f7route.params.model:
         model = props.f7route.params.model
      mode = 'form'
      self.model = model
      self.mode = mode
      id = props.f7route.query.id
      view = tools.view[model].form
      models.env.context.active_model = model
      if id:
         models.env.context.active_ids = [id]
      else:
         del models.env.context.active_ids
      if not cachedFormViews[view]:
         cachedFormViews[view] = parseFormView(view, model)
      return cachedFormViews[view]()

react.register_component(FormPage)

def parseCustomView(view, model):
    customComponents = client.components
    view = new DOMParser().parseFromString(view, 'text/xml').children[0]
    def recurse(elements, parent_props):
        components = []
        for element in elements:
            component = customComponents[element.tagName.split('-').map(def (word): return word[0].toUpperCase() + word.slice(1).toLowerCase()).join('')] if '-' in element.tagName else None or customComponents[element.tagName[0].toUpperCase() + element.tagName.toLowerCase().slice(1)] or customComponents[element.tagName] or element.tagName
            props = {'model': model}
            parseAttribute(element, props)
            if component == Tree:
               field = models.env[model]._fields[parent_props.name]
               props.view_model = model
               props.field_name = parent_props.name
               props.model = field.relation
               props.field = field.inverse if field.type == 'one2many' else parent_props.name
               if field.type != 'one2many':
                  props.parent_model = model
                  props.tree_arch = element.outerHTML
               if parent_props.invisible: props.invisible = parent_props.invisible
               if parent_props.domain: props.domain = parent_props.domain
            props.isCustomView = True
            children = recurse(element.children, props) or [def render(): element.innerHTML]
            components.push(def render(): React.createElement(component, props, children.map(def (result): return result())))
        if not components.length: return None
        return components
    return recurse([view], True)[0]

cachedCustomViews = {}

class CustomPage(React.Component):

    def componentDidUpdate(self):
        if self.afterMount:
           del self.afterMount
           return
        model = self.model
        mode = self.mode;
        tools.view[model].custom_init and tools.view[model].custom_init[model + '.' + mode]: tools.view[model].custom_init[model + '.' + mode].bind(self)(self.props)

    def componentDidMount(self):
        self.componentDidUpdate()
        self.afterMount = True
        def wait():
            self.afterMount = False
        setTimeout(wait, 1000)

    def render(self, props):
        def refresh():
            return self.setState({})
        self.refresh = refresh
        models.env.context.refresh = refresh
        model = models.env.context.active_model
        mode = models.env.context.active_mode
        if props.f7route and props.f7route.url: models.env.context.active_url = props.f7route.url
        else: models.env.context.active_url = '/'
        if props.f7route and props.f7route.params and props.f7route.params.view_id:
           view_id = props.f7route.params.view_id.split('.')
           model = view_id.slice(0, -1).join('.')
           mode = view_id[view_id.length - 1]
        self.model = model;
        self.mode = mode;
        view = tools.view[model][mode]
        if tools.view[model].contexts[mode]: Object.assign(models.env.context, tools.view[model].contexts[mode])
        models.env.context.active_model = model
        id = props.f7route && props.f7route.query.id
        if id:
           models.env.context.active_ids = [id]
        else:
           del models.env.context.active_ids
        if not cachedCustomViews[view]:
           cachedCustomViews[view] = parseCustomView(view, model)
        return cachedCustomViews[view]()


def NotFound(props):
    return
      Page(
        Navbar(title="Not found", backLink="Back"),
        Block(strong=True,
          p('Sorry'),
          p('Requested content not found.'),
        ),
      )

react.register_component(NotFound)

hide = False

def hidePanel():
    nonlocal hide
    client.api.globals.app.params.panel.leftBreakpoint = 768 if hide else 1000000
    client.api.globals.app.panel.left.initBreakpoints()
    hide = not hide

def PanelLeft(props):
    def onClick(event):
        event.preventDefault()
        client.api.globals.app.panel.left.close()
        #Object.assign(models.env.context, tools.menu[menu].context)
        client.api.globals.app.views.main.router.navigate(event.currentTarget.href.split('#!')[1])
    @async
    def installPrompt():
        client.api.globals.InstallPromp.prompt()
        if (await api.globals.InstallPromp.userChoice == 'accepted'):
           document.getElementById('pwa_install_button').style.display = 'none'
    return
      Page (
        Navbar (title="Menu"),
        div (id="menu", className="list list-block media-list chevron-center inset", style={'fontWeight': 500}, panelClose=True,
          [ul (
            li (className="accordion-item",
              a (className='item-link item-content', + (' panel-close external' if tools.menu[menu].childs.length < 1 else ''), onClick=tools.menu[menu].childs.length < 1 and onClick, href={tools.menu[menu].childs.length < 1 and '#!/' + ('view' if tools.menu[menu].view_id else 'tree') + '/' + (tools.menu[menu].view_id or tools.menu[menu].model)} data-view="#main-view",
                div (className="item-inner",
                  div (className="item-title", tools.menu[menu].string),
                )
              ),
              [div (className="accordion-item-content",
                a (className="item-content panel-close external", onClick=onClick, href='#!/' + ('view' if child_menu.view_id else 'tree') + '/' + (child_menu.view_id or child_menu.model), data-view="#main-view",
                  div (className="item-inner",
                    div (className="item-title", child_menu.string),
                  )
                )
              for child_menu, index in enumerate(tools.menu[menu].childs))],
            )
          for menu, index in enumerate(tools.keys(tools.menu, 'sequence')))]
        )
        Button (fill=True, id="pwa_install_button", onClick=installPrompt, style={'display': 'inline-block' if api.globals.InstallPrompt else 'none', margin: '10px'}, "Install"),
        Link (iconMd="material:more_horiz", iconSize="30", onClick=hidePanel, style={display: 'inline-block', margin: '10px'})
      )

react.register_component(PanelLeft)

class PanelRight(React.Component):

    @async
    def componentDidMount(self, props):
        api.globals.app = self.$f7
        client.app = api.globals.app
        if client.app.device.ios:
           color = document.querySelector('meta[name=theme-color]').content
           style = document.createElement('style')
           style.innerHTML = '#framework7-root {padding-top: 24px !important; background-color: ' + color + ' !important} .panel {padding-top: 24px !important; background-color: ' + color + ' !important}'
           document.querySelector('head').append(style)
        tools.navigate = client.app.views.main.router.navigate.bind(client.app.views.main.router)
        tools.dialog = client.app.dialog
        user_id = await [models.env.user.browse(models.env.user.id.toString())]
        return self.setState({'name': user_id.name})

    def render(self, props):
        Page(
          Navbar(
            NavLeft (className="user-link",
              List(
                ListItem (link="#", title=this.state.name or '',
                  Icon (material="person")
                )
              )
            )
          )
          Toolbar (tabbar=True,
            Link (tabLink="#notification", tabLinkActive=True, "Notifications"),
          )
          Tabs(
            Tab (id="notification", className="page-content", tabActive=True, style={'paddingTop': '0px'},
              List (mediaList=True, style={'marginTop': '0px'},
                ListItem (link="#", title="Notification Title", after="17:20", text="Notification Text",
              )
              Button fill (onClick=client.api.logout, style={'display': 'inline-block', margin: '10px'}, "Logout"),
            )
          )

react.register_component(PanelRight)
