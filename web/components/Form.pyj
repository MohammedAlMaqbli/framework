import orm.models as models
import orm.tools as tools
import web.react as react
import web.components.Page

Button, div, span = react.get_framework_components('Button', 'div', 'span')
Page = react.get_components('Page')

class Form(React.Component):

    def __init__(self, props):
        models.env.context.editing = True if props.isCustomView else False;
        self.state = models.env.context
        self.state.edit_function = self.edit.bind(self)

    @async
    def componentDidMount(self):
        model = models.env.context.active_model
        models.env.context.active_lines = {}
        models.env.context.active_task = []
        if not models.env.context.active_ids or models.env.context.active_ids.length < 1 or not models.env.context.active_ids[0]:
           models.env.context.active_id = models.env[model].browse()
           await [models.env.context.active_id._wait_promise()]
           models.env.context.editing = True
           return this.setState(models.env.context)
        models.env.context.active_id = await [models.env[model].browse(models.env.context.active_ids)]
        window.c = models.env.context.active_id
        return models.env.context.refresh()

    @async
    def edit(self):
        def wait():
            return not tools.client.api.globals.onchange_running
        await [tools.client.api.wait_exist(wait)]
        model = models.env.context.active_id._name
        offline = JSON.parse({'True': 'true', 'False': 'false'}[self.props.offline] or self.props.offline) if self.props.offline else False
        if not self.state.editing:
           models.env.context.editing = True
           return this.setState(tools.merge({}, models.env.context, {'offline': offline}))
        operation = 'write' if models.env.context.active_id.id else 'create'
        try:
            await [models.env.context.active_id[operation]({}, not offline)]
        except Exception as error:
            if error and error.constructor == tools.exceptions.RequiredError:
               error.field_map = {}
               for field in error.fields:
                   error.field_map[field] = True
               models.env.context.active_error = error;
               await [this.setState({'active_id': models.env.context.active_id})]
               tools.client.app.toast.create({'text': 'Some fields are required', 'closeButton': False, 'closeTimeout': 2000, position: 'center'}).open()
               return
            else:
               raise error
        for task in models.env.context.active_task:
            result = task()
            if result and result.constructor == Promise: await (result)
        models.env.context.active_task = [];
        if operation == 'create':
           tools.client.app.views.main.router.navigate(window.location.hash.replace('#!', '') + '?id=' + models.env.context.active_id.id, {'reloadCurrent': True})
           promises = []
           for model in models.env.context.active_lines:
               for inverse_field in models.env.context.active_lines[model]:
                   if inverse_field.slice(0, 10) == 'many2many_': continue
                   promises.push(models.env.context.active_lines[model][inverse_field].write({inverse_field: models.env.context.active_id.id}))
           await (promises)
        if not self.props.isCustomView: models.env.context.editing = False
        if offline:
           if not models.env.context.unsaved: models.env.context.unsaved = {}
           if not models.env.context.unsaved[model]: models.env.context.unsaved[model] = {}
           models.env.context.unsaved[model][models.env.context.active_id.id] = models.env.context.active_id.id
        await [tools.client.api.update_session({'unsaved': models.env.context.unsaved})]
        await [self.setState(tools.merge({}, models.env.context, {'offline': offline}))]

    @async
    def upload(self):
        def wait():
            return not tools.client.api.globals.onchange_running
        await [tools.client.api.wait_exist(wait)]
        model = models.env.context.active_id._name;
        record = await [models.env[model].browse(models.env.context.active_id.id)]
        if record.length < 1:
           values = models.env.context.active_id.read()
           del values.id
           record = await [models.env.context.active_id.create(values)]
           await [models.env.context.active_id.unlink(False)]
           models.env.context.active_id = record
        else:
           record = await [models.env.context.active_id.write()]
           models.env.context.active_id = record
        if models.env.context.unsaved and models.env.context.unsaved[model] and models.env.context.unsaved[model][record.id]: del models.env.context.unsaved[model][record.id]
        await [tools.client.api.update_session({'unsaved': models.env.context.unsaved})]
        return this.setState(tools.merge({}, models.env.context, {'offline': False}))

    def render(self, props):
        #self.state = models.env.context
        #self.state.edit_function = self.edit.bind(self)
        #if props.isCustomView: models.env.context.editing = True
        model = models.env.context.active_model
        buttonStyle = {'width': 'auto', 'float': 'left', 'margin-right': '10px'};
        uploadStyle = {}
        if not self.state.offline: uploadStyle['display'] = 'none'
        if props.isCustomView: return Page (title=tools.view[model].string, props.children)
        def onClickEdit():
            return self.edit().catch(tools.client.api.handleClientError)
        def onClickCancel():
            return tools.client.app.views.main.router.back()
        return (
          Page (title=tools.view[model].string,
            div (className="card", style={'margin': 0, 'boxShadow': 'none'},
              div (className="card-header", style={'borderRight': 'solid rgba(0,0,0,0.05) 0.5px'},
                div (className="data-table-title",
                  tools.view[model].string,
                  span (style={'color': '#666666'}, ' / ' + (self.state.active_id.name if self.state.active_id and self.state.active_id.id else 'New')),
                  div(
                    Button (onClick=onClickEdit, style=buttonStyle, fill=True, 'Save' if self.state.editing else 'Edit'),
                    Button (onClick=onClickCancel, style=tools.merge({}, buttonStyle, {'display': 'none'} if not self.state.editing else {}),'Cancel'),
                    Button (onClick=self.upload.bind(self), style=tools.merge({}, buttonStyle, uploadStyle), fill=True, 'Upload'),
                  )
                )
              ),
              props.children,
            )
          )
        )

react.register_component(Form)
