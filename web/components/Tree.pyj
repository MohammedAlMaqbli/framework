import orm.models as models
import orm.tools as tools
import web.react as react
import web.components.Page
import web.components.Grid
import web.components.GridEditor
import web.components.GridCheckbox

api = client.api
csv = client.csv
FileSaver = client.FileSaver

Button, Popup = react.get_framework_components('Button', 'Popup')
Page, Grid, GridEditor, GridCheckbox = react.get_components('Page', 'Grid', 'GridEditor', 'GridCheckbox')

def autoSizeAll(gridOptions, listener):
    if this:
        this.gridOptions = gridOptions
        def click():
            return gridOptions.api.onFilterChanged()
        for column in gridOptions.api.gridCore.gridOptions.columnDefs:
            gridOptions.api.getFilterInstance(column.field).eClearButton.addEventListener('click', click)
        
    div = gridOptions.api.gridCore.eGridDiv
    overflown = any(element.offsetWidth < element.scrollWidth for element in div.querySelectorAll('span.ag-header-cell-text'))

    if not overflown:
        gridOptions.api.sizeColumnsToFit()
        for element in document.querySelectorAll('div.ag-paging-panel'):
            element.style.width = parseFloat(element.parentElement.querySelector('.ag-header-viewport .ag-header-row').style.width.replace('px', '')) - 48 + 'px'
        if document.getElementById('rapyd-maximum-tree-width'):
            if document.querySelector('.panel-visible-by-breakpoint'): document.getElementById('rapyd-maximum-tree-width').innerHTML = document.getElementById('rapyd-maximum-tree-width').innerHTML.replace('.component-group, .component-sheet {width: 46.5vw}', '')
            elif document.getElementById('rapyd-maximum-tree-width').innerHTML.indexOf('.component-group, .component-sheet {width: 46.5vw}') == -1: document.getElementById('rapyd-maximum-tree-width').innerHTML += '.component-group, .component-sheet {width: 46.5vw}'
        return

    @async
    def forceResize():
        await [api.wait(200)]
        allColumnIds = []
        for column in gridOptions.columnApi.getAllColumns():
            allColumnIds.push(column.colId)
        gridOptions.columnApi.autoSizeColumns(allColumnIds)
        popups = Array.prototype.slice.call(document.querySelectorAll('div.popup'))
        maxWidth = Math.max(*[parseFloat(element.style.width.replace('px', '')) for element in document.querySelectorAll('div.ag-header-row') if element.offsetParent and not [popup.contains(element) for popup in popups].length])
        popupWidth = 0
        if popups.length:
           popupWidth = Math.max(*[parseFloat(element.style.width.replace('px', '')) for element in document.querySelectorAll('div.ag-header-row') if element.offsetParent and [popup.contains(element) for popup in popups].length])
        style = document.getElementById('rapyd-maximum-tree-width') or document.createElement('style')
        style.id = 'rapyd-maximum-tree-width';
        style.innerHTML = '.rapyd-card-sheet {min-width: ' + (maxWidth + 30) + 'px}';
        if not document.querySelector('.panel-visible-by-breakpoint'): style.innerHTML += '\n.component-group, .component-sheet {width: 46.5vw}'
        if popupWidth and popupWidth != -Infinity: style.innerHTML += '\n .popup .rapyd-card-sheet {min-width: ' + (popupWidth + 30) + 'px}'
        document.querySelector('head').append(style)
        for element in document.querySelectorAll('div.ag-paging-panel'):
            element.style.width = parseFloat(element.parentElement.querySelector('.ag-header-viewport .ag-header-row').style.width.replace('px', '')) - 48 + 'px'
    forceResize()        

class Tree(React.Component):

    def __init__(self, props):
        model = props.model or models.env.context.active_model
        this_tree = self

        def isEditable(params):
            if this:
                self = this
            result = None
            if props.isTreeView and not props.editable:
                return False

            if models.env.context.editing:
                return True

            if result and self and self != this_tree:
                context = models.env.context
                model = props.model or models.env.context.active_model
                field = models.env[model]._fields[self.props.name]
                active_id = context.active_lines[this_tree.state.model][('many2many_' if this_tree.props.parent_model else '') + this_tree.state.tree_field].find(this_tree.state.records[params.node.rowIndex].id or this_tree.state.records[params.node.rowIndex]._original_object_for_id)
                readonly = field.readonly or self.props.readonly
                return not (readonly(active_id) if v'readonly instanceof Function' else readonly)

            return result or False

        self.isEditable = isEditable
        self.pendingTask = {'create': False, 'write': False, 'tasked': False}
        self.pendingCreate = False
        self.pendingWrite = False

        def taskJob():
            if self.pendingTask.tasked: return
            self.pendingTask.tasked = True
            @async
            def task():
                if self.pendingTask.create: await [self.state.new_records.create()]
                if self.pendingTask.write: await [models.env.context.active_lines[self.state.model][('many2many_' if self.props.parent_model else '') + self.state.tree_field].write()]
                if self.props.parent_model: models.env.context.active_id.write({self.state.tree_field: models.env.context.active_lines[self.state.model]['many2many_' + self.state.tree_field].ids})
            models.env.context.active_task.push(task)
        self.taskJob = taskJob

        def onchange(params):
            if not params.colDef.cellEditorFramework and params.newValue != params.oldValue:
                value = params.newValue
                records = models.env.context.active_lines[self.state.model][('many2many_' if self.props.parent_model else '') + self.state.tree_field]
                record = records.find(params.data.id) if params.data.id else records.find(params.data._original_object_for_id)
            if not self.pendingTask.write and record.id:
                self.pendingTask.write = True

            elif not self.pendingTask.create and not record.id:
                self.pendingTask.create = True

            if not self.pendingTask.tasked and (self.pendingTask.create or self.pendingTask.write):
                self.taskJob()

            record[params.colDef.field] = value

            if not params.selectedOnchange and self.state.selected:
                for row in self.state.selected:
                    if row == params.data: continue
                    self.onChange({'colDef': params.colDef, 'selectedOnchange': True, 'data': row, 'specialValue': params.specialValue, 'oldValue': None, 'newValue': value})
                    row[params.colDef.field] = params.specialValue or value
                @async
                def wait():
                    await [api.wait(100)]
                    self.gridOptions.api.deselectAll()
                    await [self.setState({records: self.state.records})]
                    if not params.colDef.cellEditorParams: self.gridOptions.api.refreshCells()
                wait()

        self.onChange = onChange

        def onSelectionChanged(event):
            selected = event.api.getSelectedRows()
            if selected.length > self.state.limit: selected = selected.slice(self.state.limit * event.api.paginationGetCurrentPage(), self.state.limit * (event.api.paginationGetCurrentPage() + 1));
            ids = []
            for data in selected:
                if data.id: ids.push(data.id)

            self.pagingCalled = True
            @async
            def wait():
                await [api.wait(100)]
                self.pagingCalled = False
            return self.setState({'active_ids': ids, 'selected': selected})

        self.onSelectionChanged = onSelectionChanged
 
        def handleOutside(event):
            if self.refs.grid and not self.refs.grid.base.querySelector('div.ag-body').contains(event.target) and self.gridOptions: self.gridOptions.api.stopEditing()

        self.handleOutside = handleOutside

        children = props.children if props.children.constructor == Array else [props.children]
        fields = []
        for child in children:
            field = {'headerName': child.attributes.string or models.env[model]._fields[child.attributes.name].string, 'field': child.attributes.name, 'supperssMovable': True, 'filterParams': {'applyButton': True, 'clearButton': True, 'newRowsAction': 'keep'}, 'editable': models.env[model]._fields[child.attributes.name].type != 'boolean' and isEditable.bind(child), 'invisible': child.props.invisible, 'onCellValueChanged': self.onChange}
            if child.props.sort:
                self.default_sort = child.props.name + ' ' + child.props.sort
                field['sort'] = child.props.sort
            if models.env[model]._fields[child.attributes.name].type in ['date', 'datetime', 'selection', 'boolean'] or models.env[model]._fields[child.attributes.name].relation:
               field = tools.merge(field, {'cellEditorFramework': models.env[model]._fields[child.attributes.name].type != 'boolean' and GridEditor, 'cellEditorParams': tools.merge({}, child.props, {'model': model, 'tree': self}), 'cellRendererParams': tools.merge({}, child.props, {'model': model, 'tree': self}), 'cellClass': 'editable-special-cell', 'cellRendererFramework': models.env[model]._fields[child.attributes.name].type == 'boolean' and GridCheckbox})
        fields[0].checkboxSelection = True
        fields[0].headerCheckboxSelection = True
        limit = parseInt(props.limit) or (50 if props.isTreeView else 500)
        records = []
        self.state = {'fields': fields, 'records': records, 'new_records': models.env[model], 'limit': limit, 'model': model, 'frameworkComponents': {'specialEditor': GridEditor}, 'selected': []}
        if props.field:
            self.state.tree_field = props.field

    def componentDidUpdate(self):
        if self.gridOptions:
          if window.innerWidth == self.lastWidth: return
          else: self.lastWidth = window.innerWidth
          autoSizeAll(self.gridOptions)

    def componentDidMount(self):
        def prompt_limit():
            def limit_tree(limit):
                self.state.limit = parseInt(limit)
                self.paging(0, {'newData': False, 'forceUpdate': True})
            api.globals.app.dialog.prompt('', 'Limit', limit_tree)
            input = document.querySelector('input.dialog-input')
            if input:
                input.type = 'number'
                input.value = self.state.limit
        if self.refs.grid and self.refs.grid.base:
            if self.props.isTreeView and self.refs.grid.base.querySelector('span.ag-paging-row-summary-panel'): self.refs.grid.base.querySelector('span.ag-paging-row-summary-panel').onclick = prompt_limit

        document.addEventListener('mousedown', self.handleOutside)

    def componentWillUnmount(self):
        document.removeEventListener('mousedown', self.handleOutside)
        window.removeEventListener('resize', self.resizeListener)
        if not self.props.isPopup and document.getElementById('rapyd-maximum-tree-width'): document.getElementById('rapyd-maximum-tree-width').remove()

    def paginate(self, rows, index=0):
        if rows.length < 1:
            return rows
    
        count = rows[0]._search_count
        default_row = tools.copy(rows[0])
        for key in default_row:
            default_row[key] = None

        if index > 0:
          pushed = 0
          while pushed < self.state.limit * index:
            rows.unshift(default_row)
            pushed += 1
                  
        while rows.length < count:
          rows.push(default_row)

        return rows

    def sort(self, fields, params):
        if fields.length > 0:
          models.env.context.active_sort = fields[0].colId + ' ' + fields[0].sort
        else:
          del models.env.context.active_sort

        if params.api.paginationGetCurrentPage() != 0:
           params.api.paginationGoToFirstPage()
        else:
           params.newData = False
           params.forcePopup = True
           params.forceUpdate = True
           self.paging.bind(this)(0, params)

    @async
    def filter(self, fields, params):
        if self.state.tree_field:
            def wait(): return models.env.context.active_id
            await [api.wait_exist(wait)]
        args = []
        values = []
        for field in fields:
            conditions = [fields[field]]
            operator = 'AND'
            if fields[field].operator != undefined:
                conditions = [fields[field].condition1, fields[field].condition2]
                operator = fields[field].operator

            types = {'startsWith': 'ilike', 'endsWith': 'ilike', 'contains': 'ilike', 'notContains': 'not ilike', 'equals': '=', 'notEqual': '!='};
            if operator == 'OR':
                args.push('|')

            for condition in conditions:
                values.push(condition.filter)
                if models.env[self.state.model]._fields[field].relation:
                   relation = models.env[models.env[self.state.model]._fields[field].relation]
                   result_ids = await [relation.search([relation._rec_name or 'name', types[condition.type], condition.filter])]
                   args.push([field, 'in', result_ids.ids])
                   continue
                args.push([field, types[condition.type], condition.filter])

        self.args = args

        if params.api.paginationGetCurrentPage() != 0:
            await [params.api.paginationGoToFirstPage()]
        else:
            params.newData = False
            params.forcePopup = True
            params.forceUpdate = True
            await [self.paging.bind(this)(0, params)]

    @async
    def paging(self, index, params):
        if self.pagingStarted and not document.getElementsByClassName('preloader-modal').length: self.pagingStarted = False
        if params.newData != False or (not params.forceUpdate and not self.props.isTreeView) or self.pagingStarted:
            return
        if index == 0 and self.props.isPopup and not params.forcePopup:
            return
        try:
            if self.state.tree_field:
                def wait(): return models.env.context.active_id
                await [api.wait_exist(wait)]
            if self.state.tree_field  and (not models.env.context.active_id or self.props.view_model != models.env.context.active_id._name): return
            if params.deleting:
                if not self.args: self.args = []
                self.args.push(['id', 'not in', self.state.active_ids])

            if not self.page_domain and api.globals.app.view.main.router.currentRoute.query.domain:
                self.page_domain = JSON.parse(api.globals.app.view.main.router.currentRoute.query.domain)

            args = ([['id', 'in', models.env.context.active_id[self.props.field_name] or []]] if self.props.field_name else []).concat(self.page_domain or [])
            if self.args: args.push(*self.args)
            models.env.context.active_args = args
            models.env.context.active_limit = self.state.limit
            models.env.context.active_index = index
            if  not models.env.context.active_sort and self.default_sort: (models.env.context.active_sort = self.default_sort) and del self.default_sort
            self.pagingStarted = True
            current_args = tools.list(*args, *((self.props.domain({}) if v'self.props.domain instanceof Function' else self.props.domain) or []))
            if models.env.context.editing and self.last_args and self.last_args == JSON.stringify(current_args): return
            self.last_args = JSON.stringify(current_args)
            records = await [models.env[self.state.model].search(*current_args)]
            if not self.props.isTreeView:
                if not models.env.context.active_lines: models.env.context.active_lines = {}
                if not models.env.context.active_lines[self.state.model]: models.env.context.active_lines[self.state.model] = {}
                if not models.env.context.active_lines[self.state.model][('many2many_' if self.props.parent_model else '') + self.state.tree_field]:
                    models.env.context.active_lines[self.state.model][('many2many_' if self.props.parent_model else '') + self.state.tree_field] = records
                else:
                    records = models.env.context.active_lines[self.state.model][('many2many_' if self.props.parent_model else '') + self.state.tree_field].add(records)
            else:
                records.add(self.state.new_records)

            if records.length > 0:
                if not self.props.isTreeView and self.args:
                    def filter(record):
                        domain = tools.copy(self.args)
                        for args in domain:
                            if (Array.isArray(args)) args[0] = record[args[0]]
                        return tools.apply_domain(*domain)
                    records = records.filter(filter)
                records = await [records.sort_by(*([records._rec_name or 'name', False] if not models.env.context.active_sort else [False if value == 'asc' else value for value in models.env.context.active_sort.split(' ')]).read(True, [field.field for field in self.state.fields]), index)]
                await [self.setState({'records': self.paginate(records), 'limit': self.state.limit})]
            elif records.length == 0: await [self.setState({'records': []})]
        except Exception as error:
          console.error(error)

    @async
    def addItem(self):
        if not self.isEditable(): return
        record = models.env[self.state.model].browse()
        if models.env.context.active_id.id and not self.props.parent_model:
            record[self.state.tree_field] = models.env.context.active_id.id
        if record._pending_promises.length > 0:
          await [record._wait_promise()]
          if not self.pendingTask.tasked:
            self.pendingTask.create = True
            self.taskJob()

        values = await [record.read(True, [field.field for field in self.state.fields])]
        self.state.new_records.add(record)
        self.state.records.push(values[0])
        if not self.props.treeView:
            models.env.context.active_lines[self.state.model][('many2many_' if self.props.parent_model else '') + self.state.tree_field].add(record)
        await [self.setState({'records': self.state.records, 'new_records': self.state.new_records})]
        self.gridOptions.api.updateRowData({'add': values})
      
    @async
    def chooseItem(self):
        await [self.refs.popup.paging(0, {'newData': False, 'forcePopup': True})]
        node = self.refs.popup_modal.getDOMNode()
        node.className = 'popup modal-in'
        node.children[0].className = node.children[0].className.replace('page-next', '').replace('page-previous', '')
        autoSizeAll(self.refs.popup.gridOptions)
        return

    @async
    def selectItem(self):
        if self.state.active_ids.length > 0:
          selected_ids = await [models.env[self.props.model].browse(self.state.active_ids)]
          records = models.env.context.active_lines[self.props.model][('many2many_' if self.props.many2many else '') + self.props.active_field].add(selected_ids)
          models.env.context.active_id[self.props.active_field_name] = records
          await [models.env.context.active_id._wait_promise()]
          await [self.props.parent_tree.paging(0, {'newData': False, 'forceUpdate': True})]
          self.gridOptions.api.deselectAll()
          self.props.parent_tree.refs.popup_modal.getDOMNode().className = self.props.parent_tree.refs.popup_modal.getDOMNode().className.replace('modal-in', 'modal-out')

    @async
    def removeItem(self):
        if self.props.isTreeView:
            records = await [models.env[self.state.model].browse(self.state.active_ids)]
            await [records.unlink()]
            await [self.paging.bind(this)(0, {newData: False})]
            return self.gridOptions.api.deselectAll()

        field = models.env[self.props.parent_model or self.state.model]._fields[self.state.tree_field]
        type = field.type
        for data in self.state.selected:
            index = self.state.records.length
            while (v'index--'):
                if data == self.state.records[index]:
                    self.state.records.splice(index)

            if not models.env.context.active_id.id or type != 'many2one':
                console.log(type)
                records = models.env.context.active_lines[self.state.model][('many2many_' if self.props.parent_model else '') + self.state.tree_field]
                values = records.values
                if not Array.isArray(values):
                  if type != 'many2one':
                    if data._original_object_for_id and data._original_object_for_id == values:
                        records._values[0] = {}
                    elif data.id == values.id:
                        (records._values[0] = {}) and del records._values[data.id]
                    continue
                  if data._original_object_for_id == values if data._original_object_for_id else data.id == values.id: models.env.context.active_lines[self.state.model][('many2many_' if self.props.parent_model else '') + self.state.tree_field] = models.env[self.state.model]
                  continue;
                index = values.length
                while (v'index--'):
                  if data._original_object_for_id and data._original_object_for_id == values[index]: values.splice(index)
                  elif not data._original_object_for_id and data.id == values[index].id: values.splice(index) or del records._values[data.id]
                continue

            if type != 'many2one': continue
            params = {'data': data}
            params.oldValue = ""
            params.newValue = None
            params.colDef = {'field': self.state.tree_field}
            self.onChange(params)

        selected = self.state.selected

        if type != 'many2one':
            models.env.context.active_id[self.state.tree_field] = models.env.context.active_lines[self.state.model][('many2many_' if self.props.parent_model else '') + self.state.tree_field]

        await [self.paging.bind(this)(0, {'newData': False, 'deleting': True, 'forceUpdate': True})]
        return self.gridOptions.api.deselectAll()

    def exportItem(self):
        if not self.state.selected:
            return self.gridOptions.api.deselectAll()
        FileSaver.saveAs(new Blob([csv.serialize({'fields': [{'id': key} for key in self.state.selected[0]], 'records': self.state.selected})], {'type': 'text/csv;charset=utf-8'}), document.getElementById('main-view').querySelector('div.title').innerText + '.csv')
        return self.gridOptions.api.deselectAll()

    def render(self, props):
        model = props.model or models.env.context.active_model
        def editableHeight():
            if self.isEditable(): return 30
            return 0
        choose = props.parent_model
        if props.choose != undefined:
           choose = props.choose(models.env.context.active_id) if v'props.choose instanceof Function' else props.choose
        invisible = props.invisible(models.env.context.active_id) if v'props.invisible instanceof Function' else props.invisible
        def onGridReady(params):
            autoSizeAll.bind(self)(params)
            def resizeListener():
                return autoSizeAll(params, self.resizeListener)
            self.resizeListener = resizeListener
            window.addEventListener('resize', self.resizeListener)
        @async
        def onRowClicked(params):
            record = await [models.env[self.state.model].browse(None)]
            del models.env.context.active_id
            api.globals.app.views.main.router.navigate('/form/' + model + '?id=' + params.data.id)
        def onPaginationChanged(params):
            return self.paging(params.api.paginationGetCurrentPage(), params)
        def onSortChanged(params):
            return self.sort(params.api.getSortModel(), params)
        def onFilterChanged(params):
            return self.filter(params.api.getFilterModel(), params)
        @async
        def onClickButton():
            records = await [models.env[self.state.model].browse(self.state.active_ids)]
            await [records[function_name]()]
            self.gridOptions.api.deselectAll()
        columnDefs = [field.field for field in self.state.fields if not (not props.isTreeView and models.env.context.active_id and v'field.invisible instanceof Function' and field.invisible({}, models.env.context.active_id)) or field.invisible]
        grid = (
          div (className="card-body" + (' rapyd-tree-is-invisible' if invisible else ''), style=tools.merge({'height': Math.min(self.state.records.length, self.state.limit) * 48 + 112 + editableHeight() + 'px'}, {'position': 'absolute', 'left': '-9999px', 'top': '-9999px'} if invisible else {}),
            Grid (ref="grid",  onSelectionChanged=self.onSelectionChanged, paginationPageSize=self.state.limit, columnDefs=columnDefs, rowData=self.state.records, frameworkComponents=self.state.frameworkComponents),
            Button (onClick=self.addItem.bind(self), style={'display': self.isEditable() and 'inline-block' if (props.create(models.env.context.active_id) if v'props.create instanceof Function' else props.create) != False else 'none', 'top': '-45px', 'backgroundColor': '#fff'}, "Add"),
            Button (onClick=self.chooseItem.bind(self), style={'display':  'inline-block' if choose and self.isEditable() else 'none', 'top': '-45px', 'backgroundColor': '#fff'},"Choose"),
            Button (onClick=self.selectItem.bind(self), style={'display':  'inline-block' if props.isPopup and self.state.selected.length > 0 else 'none', 'top': '-45px', 'backgroundColor': '#fff'},"Select"),
            Button (onClick=self.exportItem.bind(self), style={display: props.isTreeView and 'inline-block' if self.state.selected.length > 0 else 'none', 'top': '-45px', 'backgroundColor': '#fff'},"Export"),
            not props.isPopup and tools.view[self.state.model] and tools.view[self.state.model].actions.tree and [
              Button (onClick=onClickButton, style={'display': 'inline-block' if (props.isTreeView or not models.env.context.editing) and self.state.selected.length > 0 else 'none', 'top': '-45px', 'backgroundColor': '#fff'}, string)
            for function_name, string in Object.entries(tools.view[self.state.model].actions.tree)],
            Button (className="rapyd-tree-delete-button", onClick=self.removeItem.bind(self), style={'display': 'inline-block' if (props.isTreeView or self.isEditable()) and not props.isPopup and self.state.selected.length > 0 else 'none', 'top': '-45px', 'backgroundColor': '#fff'},"Delete"),
            not props.isTreeView and (props.parent_model or choose) and
            Popup (ref="popup_modal", backdrop=False, animate=True,
              Page (popup=True, title=tools.view[this.state.model].string if tools.view[this.state.model] else 'Choose',
                div (className='card rapyd-card-sheet',
                  Tree (ref='popup', isTreeView=True, isPopup=True, many2many=not not props.parent_model, parent_tree=self, active_field=self.state.tree_field, active_field_name=props.field_name, model=self.state.model, domain=[['id', 'not in', models.env.context.active_lines[props.model][('many2many_' if this.props.parent_model else '') + this.state.tree_field].ids]] if this.state.records.length > 0 else []).concat(props.domain(models.env.context.active_id) if props.domain  else [], [
                    React.createElement(None, tools.merge({'model': model}, {attribute.name: attribute.value for attribute in element.attributes}))
                  for element in (new DOMParser().parseFromString((tools.view[this.state.model] and tools.view[this.state.model].tree) or '<tree><field name="' + (models.env[this.state.model]._rec_name or 'name') + '"/></tree>', 'text/xml').children[0].children)])
                )
              )
            )
          )
        )
        if not props.isTreeView or props.isPopup:
          if models.env.context.editing:
            del grid.props.children[0].props.onRowClicked
          return grid

        def onClickCreate():
            api.globals.app.views.main.router.navigate('/form/' + model)
        return (
          Page (title=props.title or tools.view[self.state.model].string,
            div (className="card rapyd-card-sheet",
              div (className="card-header",
                div (className="data-table-title",
                  props.title or tools.view[self.state.model].string,
                  br(),
                  Button (onClick=onClickCreate, style={'display': 'inline-block'}, fill,"Create"),
                )
              ),
              grid,
            )
          )
        )

react.register_component(Tree)
