import orm.models as models
import orm.tools as tools
import web.react as react
import web.components.Flatpickr

Button, List, ListInput, div, span, i = react.get_framework_components('Button', 'List', 'ListInput', 'div', 'span', 'i')

Flatpickr = react.get_components('Flatpickr')

Flatpickr = react.get_components('Flatpickr')

selectivityOverrided = False

def overrideSelectivityTemplates():
    nonlocal selectivityOverrided
    if selectivityOverrided: return
    selectivity = tools.client.selectivity
    Selectivity = selectivity.Selectivity
    Templates = selectivity.Templates
    singleSelectInput = Templates.singleSelectInput
    Templates.singleSelectInput =
    def (options):
        return singleSelectInput(options).replace('<i class="fa fa-sort-desc selectivity-caret"></i>', '<i class="selectivity-caret material-icons">expand_more</i>')

    singleSelectedItem = Templates.singleSelectedItem
    Templates.singleSelectedItem =
    def (options):
        return singleSelectedItem(options).replace('<i class="fa fa-remove"></i>', '<i class="selectivity-remove material-icons">close</i>')

    multipleSelectedItem = Templates.multipleSelectedItem
    Templates.multipleSelectedItem =
    def (options):
        return multipleSelectedItem(options).replace('<i class="fa fa-remove"></i>', '<i class="selectivity-remove selectivity-multi-remove material-icons">close</i>');
    selectivityOverrided = True

class Field(React.Component):

    def __init__(self):
        self.refs = {}
        overrideSelectivityTemplates()

    @async
    def setValue(self, value, altvalue):
        props = self.props;
        tools.client.api.globals.onchange_running = True
        await [tools.client.api.wait(0)]
        tools.client.api.globals.onchange_running = False
        models.env.context.active_error and (models.env.context.active_error.field_map[self.props.name] = False)
        if self.input_type and self.input_type == 'file' and value:
           value = await [tools.client.api.readAsDataURL(value)]
           value = value.split('base64,')[1]
        if not self.props.cellEdit: models.env.context.active_id[self.props.name] = value
        else return models.env.context.refresh()
        await [models.env.context.active_id._wait_promise()]
        model = props.model
        field = models.env[model]._fields[props.name]
        type = field.type
        if self.refs.input:
           await [self.setInputValue(value)]
        elif type in ['many2many', 'one2many', 'many2one', 'one2one'] and not props.children:
           await [self.setSelectivityValue(altvalue)]
        elif type == 'selection':
            if self.props.widget == 'statusbar': return self.setState({'value': value})
            await [self.setSelectivityValue(altvalue)]
        elif type in ['date', 'datetime']:
            await [self.setState({'value': value, 'input': self.refs.date_input.base.querySelector('input')})]
        else:
           await [self.setState({'value': altvalue or value})]
        return models.env.context.refresh()

    @async
    def setSelectivityValue(self, value):
        value = await (value)
        if not tools.exist(value): return
        if value and v'typeof value' == 'object': return self.setState({'value': value})
        def wait():
            return self.refs.selectivity
        await [tools.client.api.wait_exist(wait)]
        if value and value == self.lastSelectivity: return
        self.lastSelectivity = value
        props = self.props
        model = props.model
        field = models.env[model]._fields[props.name]
        type = field.type
        if not model:
           return
        elif type in ['many2many', 'one2many', 'many2one', 'one2one'] and not props.children:
           records = await [models.env[field.relation].browse(value)]
           if not records.length: return
           if value.constructor == String:
              return self.setState({'value': {'id': records.id, 'text': records[records._rec_name or 'name']}})
           elif Array.isArray(value):
              return self.setState({'value': [{'id': record.id, text: record[record._rec_name or 'name']} for record in records]})
        elif type == 'selection':
           selections = field.selection.apply(None) if v'typeof field.selection' == 'function' else field.selection
           return self.setState({'value': value and {'id': value, 'text': tools.dict(selections)[value]}})

    @async
    def setInputValue(self, value):
        props = self.props
        model = props.model or models.env.context.active_model
        field = models.env[model]._fields[props.name]
        type = field.type
        if type == 'binary': return
        if type == 'float' or type == 'integer': value = value or None
        if self.refs.input:
           if type not in ['text', 'data', 'boolean']:
              self.refs.input.base.querySelector('input').value = value
           elif type == 'boolean':
              self.refs.input.base.querySelector('input').checked = value;
        else:
           self.refs.input.base.querySelector('textarea').value = value if type != 'data' else JSON.stringify(value)

    @async
    def componentDidMount(self):
        def wait():
            return models.env.context.active_id
        await [tools.client.api.wait_exist(wait)]
        props = self.props
        console.log(props)
        model = props.model or models.env.context.active_model
        field = models.env[model]._fields[props.name]
        type = field.type
        context = models.env.context
        if context.active_id._pending_promises.length > 0: await [context.active_id._wait_promise()]
        value = None if props.cellEdit else context.active_id and await (context.active_id[self.props.name])
        if self.props.ref_object: Object.assign(self.props.ref_object, self.refs, {'loaded': True})
        if self.refs.input:
           return self.setInputValue(value);
        elif type in ['many2many', 'one2many', 'many2one', 'one2one'] and not props.children:
           return self.setSelectivityValue(value)
        elif type == 'selection':
           if self.props.widget == 'statusbar': return self.setState({'value': value})
           return self.setSelectivityValue(value)
        elif type in ['date', 'datetime']:
           return self.setState({'value': value, 'input': self.refs.date_input.base.querySelector('input')})
        else:
           return self.setState({'value': value})

    def componentWillUnmount(self):
        if self.refs.selectivity and self.refs.selectivity.selectivity: self.refs.selectivity.selectivity.destroy()

    def render(self, props):
        Selectivity = tools.client.selectivity.Selectivity
        model = props.model or models.env.context.active_model
        field = models.env[model]._fields[props.name]
        if not field: return
        string = props.string or field.string
        type = field.type
        types = {'char': 'text', 'text': 'textarea', 'float': 'number', 'integer': 'number', 'data': 'textarea', 'boolean': 'checkbox', 'binary': 'file'};
        context = models.env.context
        refs = self.refs
        active_id = context.active_lines[self.props.tree.state.model][('many2many_' if self.props.tree.props.parent_model else '') + self.props.tree.state.tree_field].find(self.props.tree.state.records[self.props.rowIndex].id or self.props.tree.state.records[self.props.rowIndex]._original_object_for_id) if props.cellEdit else context.active_id
        invisible = props.invisible(active_id, models.env.context.active_id) if v'props.invisible instanceof Function' and active_id else props.invisible;
        props.readonly = field.readonly or props.readonly;
        readonly = props.readonly(active_id) if v'props.readonly instanceof Function' else props.readonly;
        value = None if props.cellEdit else context.active_id and context.active_id[self.props.name];
        @async
        def fetch(url, init, query):
            try:
                limit = 10
                models.env.context.active_limit = limit
                models.env.context.active_index = query.offset / limit
                domain = props.domain(active_id, models.env.context.active_id if props.cellEdit else undefined) if active_id and props.domain else []
                records = await [models.env[field.relation].with_context(no_preload=True).search([(models.env[field.relation]._rec_name or 'name'), 'ilike', query.term], *domain)]
                if models.env.context.active_lines[field.relation]:
                   for inverse_field in models.env.context.active_lines[field.relation]:
                       records.add(models.env.context.active_lines[field.relation][inverse_field].filter(
                       def (record):
                            return record[record._rec_name or 'name'] and record[record._rec_name or 'name'].toLowerCase().indexOf(query.term.toLowerCase()) != -1
                       ))
                results = []
                if type == 'selection': return {'results': results, 'more': False}
                for record in records:
                    if not record.id:
                       id = 'etemp' + Math.random().toString(36).substr(2, 9)
                       if not tools.client.api.globals.temp_records: tools.client.api.globals.temp_records
                       tools.client.api.globals.temp_records[id] = record
                       results.push({'id': id, 'text': record[record._rec_name or 'name']})
                       continue
                    results.push({'id': record.id, 'text': record[record._rec_name or 'name']})
                models.env.context.active_index = 0
                return {'results': results, 'more': (query.offset / limit + 1) * limit < records._search_count}
            except Exception as error:
                console.error(error)
                raise error
        if type in ['many2many', 'one2many'] and props.children:
           return props.children[0]
        component = None
        if type == 'selection' and props.widget == 'statusbar':
           first = True
           selections = field.selection.apply(context.active_id, [context.active_id]) if v'typeof field.selection' == 'function' else field.selection
           selections = tools.copy(selections).reverse()
           if props.visible:
              selections = selections.filter(
              def (selection):
                  return props.visible.split(',').indexOf(selection[0]) > -1 or (models.env.context.active_id and models.env.context.active_id[props.name] == selection[0])
              )
           component = (
             div (style={'display': 'none'} if invisible else {}, overflow='overlay', [
               Button (raised=models.env.context.active_id and models.env.context.active_id[props.name] == selection[0], className="rapyd-statusbars", (first = False) or selection[1]) if first else [span (className="rapyd-statusbars rapyd-statusbar-arrow", '>'), Button (raised=models.env.context.active_id and models.env.context.active_id[props.name] == selection[0], className="rapyd-statusbars", selection[1])]
             for selection in selections])
           )
           return component
        if type in ['many2many', 'one2many', 'many2one', 'one2one', 'selection']:
           ajax = None
           items = None
           if type in ['many2many', 'one2many', 'many2one', 'one2one']:
              ajax = {'url': tools.configuration.url, 'minimumInputLength': 0, params: def (): return;, placeholder: '', fetch: fetch}
           elif type == 'selection':
              selections = field.selection.apply(context.active_id, [context.active_id]) if v'typeof field.selection' == 'selection' else field.selection
              items = [{'id': selection[0], 'text': selection[1]} for selection in selections]
           active_id = models.env.context.active_id
           @async
           def after_create():
               record = models.env.context.active_id
               def assign_record():
                   models.env.context.active_id.values = active_id.values
                   models.env.context.active_id[props.name] = record.id
                   if not models.env.context.editing: models.env.context.active_id.write()
               await [tools.client.api.wait(100)]
               tools.client.api.globals.app.views.main.router.back()
               if active_id.id:
                  def wait():
                      return models.env.context.active_id.id == active_id.id
                  await [tools.client.api.wait_exist(wait)]
               assign_record()
           icon_create = (not readonly and context.editing) and (models.env.context.active_id and not models.env.context.active_id[props.name])
           def onChange(event):
               return self.setValue(event.value, event.data)
           def onDropdownOpen():
               return self.setState({'selectivityOpened': True})
           def onDropdownClose():
               if props.onSelect: props.onSelect()
               return self.setState({'selectivityOpened': False})
           @async
           def onClickIcon():
               tools.client.api.globals.app.views.main.router.navigate('/form/' + field.relation)
               await [tools.client.api.wait(100)]
               models.env.context.active_task.push(after_create)
           component = [
             ListInput (label=string, input=False, disabled=readonly or not context.editing, errorMessageForce=models.env.context.active_error.field_map[props.name] if models.env.context.active_error else False, errorMessage="Field required", style=not props.cellEdit and type != 'selection' and icon_create and {'height': '65px'},
               Selectivity (ref="selectivity", slot="input", data=self.state.value if tools.exist(self.state.value) and self.state.value.constructor != Promise else None, ajax=ajax, items=items, placeholder=props.placeholder or '', readOnly=readonly or not context.editing, multiple=type in ['many2many', 'one2many'], allowClear=True, closeOnSelect=True, onChange=onChange, onDropdownOpen=onDropdownOpen, onDropdownClose=onDropdownClose)
             ),
             not props.cellEdit and type != 'selection' and i (className="icon material-icons", onClick=onIconClick, style={'top': '-30px', 'left': '280px', 'display': 'none' if not icon_create else 'unset'}, 'open_in_new')
           ]
           if props.cellEdit: return component[0].children[0]
           @async
           def forceSet():
               await [tools.client.api.wait(500)]
               def wait(): return context.active_id
               await [tools.client.api.wait_exist(wait)]
               value = await (context.active_id[props.name])
               return self.setSelectivityValue(value)
           forceSet()
        elif type in ['date', 'datetime']:
           input = (
             ul (
               ListInput (ref="date_input", label=string, placeholder=props.placeholder or '', disabled=readonly or not context.editing, errorMessageForce=models.env.context.active_error.field_map[props.name] if models.env.context.active_error else False, errorMessage="Field required")
             )
           )
           component = (
             Flatpickr (customComponent=input, customInput=self.state.input, enableTime=type == 'datetime', enableSeconds=type == 'datetime', defaultDate=self.state.value or value, onChange=self.setValue.bind(self))
           )
           if props.cellEdit: return component.children.children
        else:
           self.input_type = types[type]
           def onChange(event):
               return self.setValue(event.target.checked if type == 'checkbox' else event.target.files[0] if type == 'file' else event.target.value)
           component = (
             ListInput (ref="input", label=string, type=types[type], placeholder=props.placeholder or '', disabled=readonly or not context.editing, onChange=onChange, errorMessageForce=models.env.context.active_error.field_map[props.name] if models.env.context.active_error else False, errorMessage="Field required")
           )
           @async
           def forceSet():
               def wait(): return self.refs.input
               await [tools.client.api.wait_exist(wait)]
               return self.setInputValue(await (value) or await (self.state.value) or None)
           forceSet()
        return (
          List (style=tools.merge({}, {'display': 'none'} if invisible else {}, {'zIndex': '0'} if not self.state.selectivityOpened else {}),
            component
          )
        )

react.register_component(Field)
