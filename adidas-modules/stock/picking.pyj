import orm.models as models
import orm.fields as fields
import orm.tools as tools
import orm.api as api
from orm.tools import each
from ir.ui import menu, view
from ir.sequence import add_sequence
from stock.location import defaults as location_default

sequence = {}
add_sequence('stock.picking', sequence)
add_sequence('stock.picking.putting', sequence)

class StockPicking(models.Model):
    _name = 'stock.picking'

    @api.server
    def _get_picking_number(self):
        return self.env['stock.picking'].with_context(order='name desc', limit=1).search().then(
        def (picking_id):
            if picking_id.length > 0:
               name = 'Operation ' + str.zfill((parseInt(picking_id.name.split(' ')[1]) + 1).toString(), 3)
               return name
            return 'Operation 001'
        )

    def _get_type(self):
         if v'typeof window' != 'undefined':
            return window.models.env.context.default_operation_type or None

    name = fields.Char(string="Operation Number", readonly=True, index=True)
    date = fields.Datetime(string="Date", defaults=tools.date.now)
    reference = fields.Char(string="Reference")
    state = fields.Selection(['draft', 'Draft'], ['confirmed', 'Confirmed'], ['validated', 'Validated'], string="Status", defaults='draft')
    type = fields.Selection(['picking', 'Picking'], ['putting', 'Putting'], string="Type", required=True, defaults=_get_type)
    #picking_type = fields.Selection(['incoming', 'Incoming'], ['outgoing', 'Outgoing'], ['internal', 'Internal'], string="Picking Type")
    location_src_id = fields.Many2one('stock.location', string="Source Location")
    location_dest_id = fields.Many2one('stock.location', string="Destination Location")
    move_ids = fields.One2many('stock.move', 'picking_id', string="Move")
    pack_ids = fields.Many2many('stock.pack', string="Packs")
    job_ids = fields.Many2many('wcs.job', string="WCS Jobs")

    def create(self, values=False, is_client=tools.configuration.client):
        promises = []
        if v"typeof window === 'undefined'":
           for object in each(values):
               if object.type == 'putting':
                  object.location_dest_id = location_default.internal_id
                  object.location_src_id = location_default.external_id
               elif object.type == 'picking':
                  object.location_src_id = location_default.internal_id
                  object.location_dest_id = location_default.external_id
               promise = self.env['ir.sequence'].browse(sequence['stock.picking' if object.type == 'picking' else 'stock.picking.putting']).then(
               def (sequence_id): return sequence_id.get_next()
               ).then(
               def (sequence):
                   object['name'] = ('Picking ' if object.type == 'picking' else 'Putting ') + str.zfill(sequence.toString(), 3)
               )
               promises.push(promise)
        def after_create(result):
            if v"typeof window === 'undefined'": return result
            def create_move(record):
                return self.env['stock.pack'].browse(record.pack_ids).then(
                def (pack_ids):
                    promises = []
                    pack_ids.queue(
                    def (pack_id, next):
                        def create_move(qty):
                            return self.env['stock.move'].with_context(no_preload=True).create({'picking_id': record.id, 'pack_id': pack_id.id, 'product_id': pack_id.adidas_product_id, 'product_qty': qty})
                        if record.type != 'picking':
                           promise = create_move(pack_id.adidas_product_qty)
                           promises.push(promise)
                           return next()
                        promise = pack_id.current_qty.then(
                        def (qty):
                            return create_move(qty)
                        )
                        promises.push(promise)
                        next()
                    )
                    return Promise.all([] if record.type != 'picking' else promises)
                )
            def each_picking():
                promises = []
                record = None
                for record in self:
                    promises.push(create_move(record))
                if record and record.type == 'picking': return Promise.all(promises)
            models.env.context.active_task.push(each_picking)
            return result
        if promises.length: return Promise.all(promises).then(
        def (): return self.__super__('create')(values=values, is_client=is_client).then(after_create)
        )
        return self.__super__('create')(values=values, is_client=is_client).then(after_create)

    def add_pack(self):
        if v'typeof window' == 'undefined': return
        picking_id = window.models.env.context.active_id
        picking_id.env.context.is_add_pack = True
        tools.navigate('/form/stock.pack')
        setTimeout(
        def ():
            def assign_picking():
                return picking_id.write({'pack_ids': (picking_id.pack_ids or []).concat(window.models.env.context.active_id.ids)}).then(
                def (result):
                    del picking_id.env.context.is_add_pack
                    return result
                )
            def create_moves():
                pack_id = window.models.env.context.active_id
                return self.env['stock.move'].create({'picking_id': picking_id.id, 'pack_id': pack_id.id, 'product_id': pack_id.adidas_product_id, 'product_qty': pack_id.adidas_product_qty})
            window.models.env.context.active_task.push(assign_picking)
            window.models.env.context.active_task.push(create_moves)
        , 0)

    def add_move(self):
        if v'typeof window' == 'undefined': return
        window.models.env.context.default_picking_id = window.models.env.context.active_id.id
        window.models.env.context.active_pack_ids = window.models.env.context.active_id.pack_ids
        tools.navigate('/form/stock.move')

    #@api.onchange('pack_ids')
    def onchange_pack(self):
        if self.type != 'picking':
           return
        move = self.env['stock.move'].search(['id', 'in', self.move_ids], ['pack_id', 'in', self.pack_ids])
        pack = self.env['stock.pack'].browse(self.pack_ids)
        return Promise.all([move, pack]).then(
        def (result):
            move_ids, pack_ids = result
            promises = []
            added_pack_ids = [move_id.pack_id for move_id in move_ids]
            for pack_id in pack_ids:
                if pack_id.id in added_pack_ids: continue
                promise = self.env['stock.move'].browse(pack_id.move_ids).then(
                def (move_ids):
                    if not move_ids.length: return
                    values = tools.copy(move_ids._values)
                    for value in values:
                        value.picking_id = self.id
                    return self.env['stock.move'].create(values)
                )
                promises.push(promise)
            return Promise.all(promises)
        )

    @api.server
    def get_buckets(self):
        if self.type == 'putting':
           selected_buckets = []
           def find_empty():
               buckets = tools.copy(selected_buckets)
               return self.env['stock.pack'].search(['id', 'not in', self.pack_ids], ['bucket', '!=', False]).then(
               def (pack_ids):
                   for pack_id in pack_ids:
                       if pack_id.bucket not in buckets: buckets.push(pack_id.bucket)
                   if not buckets.length:
                      return ['1']
                   elif buckets.length == 34:
                      return self.env['stock.pack'].with_context(order='move_ids', limit=1).search(['bucket', '!=', False]).then(
                      def (pack_id):
                          if pack_id.length:
                             return selected_buckets.concat([pack_id.bucket])
                      )
                   else:
                      return selected_buckets.concat([str(int(tools.max(*buckets)) + 1)])
               )
           return self.env['stock.pack'].browse(self.pack_ids).then(
           def (pack_ids):
               unassigned_pack = False
               for pack_id in pack_ids:
                   if pack_id.bucket and pack_id.bucket not in selected_buckets: selected_buckets.push(pack_id.bucket)
                   elif not pack_id.bucket: unassigned_pack = True
               if unassigned_pack:
                  return find_empty()
               else:
                  return selected_buckets
           )
        elif self.type == 'picking':
           selected_packs = []
           return self.env['stock.move'].browse(self.move_ids).then(
           def (move_ids):
               unassigned_move = False
               for move_id in move_ids:
                   if move_id.pack_id and move_id.pack_id not in selected_packs: selected_packs.push(move_id.pack_id)
                   elif not move_id.pack_id: unassigned_move = True
               if unassigned_move:
                  promises = []
                  for move_id in move_ids:
                      if not move_id.pack_id:
                         promise = self.env['stock.move'].with_context(limit=1).search(['pack_id', '!=', False], ['product_id', '=', move_id.product_id.id], ['product_qty', '>=', pack_id.product_qty], ['location_dest_id', '=', location_default.internal_id], ['state', '=', 'done']).then(
                         def (move_id):
                             if move_id.length:
                                selected_packs.push(move_id.pack_id)
                         )
                         promises.push(promise)
                  return Promise.all(promises)
           ).then(
           def ():
               return self.env['stock.pack'].browse(selected_packs).then(
               def (pack_ids):
                   return Object.keys({pack_id.bucket: True for pack_id in pack_ids})
               )
           )

    @api.server
    def confirm(self):
        return self.get_buckets().then(
        def (buckets):
            promises = []
            count = 1
            for bucket in buckets:
                promise = self.env['wcs.job'].create({'name': 'Job ' + count + ' ' + self.name, 'date': Date(), 'state': 'draft', 'bucket': bucket, 'workface': '3' if self.type == 'picking' else '0', 'type': self.type, 'flag': 'online', 'priority': 1}).then(
                def (job_id):
                    def submit():
                        return job_id.submit().then(def (job_id): return job_id;)
                    if self.type == 'picking': return submit()
                    return self.env['wcs.job'].with_context(limit=1, order='date desc').search(['bucket', '=', job_id.bucket], ['state', '=', 'returned']).then(
                    def (previous_job_id):
                        if previous_job_id.length > 0 and previous_job_id.type == 'picking':
                           return job_id.write({'workface': '1'})
                    ).then(submit)
                ) #.then(
                #def (job_id):
                #    return self.write({'state': 'confirmed', 'job_id': job_id.id})
                #)
                promises.push(promise)
                count += 1
            return Promise.all(promises).then(
            def (job_ids):
                return self.write({'state': 'confirmed', 'job_ids': [job_id.id for job_id in job_ids]})
            )
        )

    @api.server
    def validate_server(self):
        """processes = []
        processes.push(self.env['wcs.job'].browse(self.job_ids))
        #if self.type == 'putting':
        #   processes.push(self.env['stock.pack'].browse(self.pack_ids))
        return Promise.all(processes).then(
        def (results):
            job_ids, pack_ids = results
            return_bucket = job_id.return_bucket()
            if self.type != 'putting': return return_bucket
            return return_bucket.then(
            def ():
                return pack_ids.write({'bucket': job_id.bucket})
            )
        )"""
        return self.env['wcs.job'].browse(self.job_ids).then(
        def (job_ids):
            promises = []
            for job_id in job_ids:
                promises.push(job_id.return_bucket())
            return Promise.all(promises)
        ).then(
        def ():
            return self.write({'state': 'validated'})
        )

    def validate(self):
        return self.validate_server().then(
        def (result):
            window.history.back()
            return result
        )

StockPicking()

menu.add({'id': 'picking', 'parent': 'stock', 'string': 'Picking', 'model': 'stock.picking', 'sequence': 1, 'view_id': 'stock.picking.tree_picking', 'context': {'default_operation_type': 'picking'}})
menu.add({'id': 'putting', 'parent': 'stock', 'string': 'Putting', 'model': 'stock.picking', 'sequence': 1, 'view_id': 'stock.picking.tree_putting', 'context': {'default_operation_type': 'putting'}})

menu.add({'id': 'picking_historical', 'parent': 'historical', 'string': 'Picking', 'model': 'stock.picking', 'sequence': 1, 'view_id': 'stock.picking.historical_picking', 'context': {'default_operation_type': 'picking'}})
menu.add({'id': 'putting_historical', 'parent': 'historical', 'string': 'Putting', 'model': 'stock.picking', 'sequence': 2, 'view_id': 'stock.picking.historical_putting', 'context': {'default_operation_type': 'putting'}})

view.add({'model': 'stock.picking', 'mode': 'tree', 'string': 'Operation', 'arch': """
<tree domain="(context.no_validated ? ['state', '!=', 'validated'] : []), ['type', '=', context.default_operation_type]">
    <field name="name"/>
    <field name="date"/>
</tree>
"""})

view.add({'model': 'stock.picking', 'mode': 'tree_picking', 'string': 'Operation', 'arch': """
<tree-page title="Picking"/>
""", 'context': {'default_operation_type': 'picking', 'no_validated': True}})

view.add({'model': 'stock.picking', 'mode': 'tree_putting', 'string': 'Operation', 'arch': """
<tree-page title="Putting"/>
""", 'context': {'default_operation_type': 'putting', 'no_validated': True}})

view.add({'model': 'stock.picking', 'mode': 'historical_picking', 'string': 'Operation', 'arch': """
<tree-page title="Picking"/>
""", 'context': {'default_operation_type': 'picking', 'no_validated': False}})

view.add({'model': 'stock.picking', 'mode': 'historical_putting', 'string': 'Operation', 'arch': """
<tree-page title="Putting"/>
""", 'context': {'default_operation_type': 'putting', 'no_validated': False}})

view.add({'model': 'stock.picking', 'mode': 'form', 'string': 'Operation', 'arch': """
<form>
    <header>
        <button name="confirm" string="Confirm" invisible="active_id.state != 'draft'"/>
        <button name="validate" string="Validate" invisible="active_id.state != 'confirmed'"/>
        <field name="state" widget="statusbar"/>
    </header>
    <sheet>
        <group>
            <field name="name" readonly="active_id.state != 'draft'"/>
            <field name="reference"/>
        </group>
        <group>
            <field name="date"/>
            <field name="type"/>
        </group>
        <group width="100%">
            <!--<button name="add_pack" string="Add Pack" invisible="active_id.type != 'putting'"/>-->
            <scanner-button invisible="active_id.type != 'picking'"/>
        </group>
        <group width="100%">
            <field name="pack_ids">
                <tree create="active_id.type == 'putting'" choose="active_id.type == 'picking'">
                    <field name="name"/>
                    <field name="order_id"/>
                    <field name="bucket" string="Rack"/>
                    <field name="adidas_product_id" domain="(active_id.article ? ['article', '=', active_id.article] : ['id', 'not in', []]), (active_id.allowed_sizes ? ['size', 'in', active_id.allowed_sizes] : ['id', 'not in', []])"/>
                    <field name="adidas_product_qty"/>
                </tree>
            </field>
        </group>
        <group width="100%" invisible="active_id.type != 'picking'">
            <button name="add_move" string="Add Items"/>
        </group>
        <group width="100%" invisible="active_id.type != 'picking'">
            <field name="move_ids">
                <tree>
                    <field name="product_id" domain="active_id.product_id ? ['id', '=', active_id.product_id] : ['id', 'not in', []]"/>
                    <field name="product_qty"/>
                    <field name="pack_id" domain="['id', 'in', parent.pack_ids || []]"/>
                </tree>
            </field>
        </group>
    </sheet>
</form>
"""})

menu.add({'id': 'settings_wms', 'string': 'WMS', 'parent': 'settings', 'model': 'stock.picking', 'view_id': 'stock.picking.settings', 'sequence': 5})

if v'typeof window' != 'undefined' and localStorage.wms_station_setting:
   localStorage.rapyd_home_view = 'stock.picking.tree_' + localStorage.wms_station_setting

def init_settings(props):
    tools.wait_exist(
    def (): return document.getElementById('wms_station_setting')
    ).then(
    def ():
        def onchange(event):
            localStorage.wms_station_setting = event.target.value
            window.location.reload()
        select = document.getElementById('wms_station_setting').querySelector('select')
        select.value = localStorage.wms_station_setting or ""
        select.onchange = onchange
    )

view.add({'model': 'stock.picking', 'mode': 'settings', 'init': init_settings, 'string': 'Operation', 'arch': """
<page title="WMS Settings">
    <list>
        <list-input label="Choose Station" type="select" id="wms_station_setting">
            <option/>
            <option value="picking">Picking Station</option>
            <option value="putting">Putting Station</option>
        </list-input>
    </list>
</page>
"""})
